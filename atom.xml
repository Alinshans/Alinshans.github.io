<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alinshans&#39;s world</title>
  <subtitle>Build a world of your own love</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.alinshans.com/"/>
  <updated>2017-09-18T15:55:27.049Z</updated>
  <id>http://www.alinshans.com/</id>
  
  <author>
    <name>刘俊延</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何自己写一个STL(下)</title>
    <link href="http://www.alinshans.com/2017/09/18/p1709181/"/>
    <id>http://www.alinshans.com/2017/09/18/p1709181/</id>
    <published>2017-09-18T12:38:46.000Z</published>
    <updated>2017-09-18T15:55:27.049Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点忙，忙里抽点空出来把这个系列给补完吧！</p>
<h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>首先，我再强调一遍，你至少要达到以下的要求：</p>
<ul>
<li>了解 STL，使用过 STL</li>
<li>了解模板</li>
<li>了解常用数据结构的原理</li>
<li>C++基础知识（Effective系列丛书）</li>
</ul>
<p>并且我推荐在动手之前至少有了解过 C++ 的代码规范，不然以后大量重构的时候就很难受了。</p>
<h3 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h3><p>具备以上要求之后，就要开始定 Scope 了。首先要明白，标准中并没有 <code>STL</code> 的说法，这里我说的 <code>STL</code> 主要指标准中容器库及算法库的部分，还包括一些内存管理、函数对象等。可以看看在 <a href="https://www.zhihu.com/question/53085291" target="_blank" rel="external">这个问题</a> 下 @陈硕 的回答。然后想想自己要做到什么程度。</p>
<h3 id="实现顺序"><a href="#实现顺序" class="headerlink" title="实现顺序"></a>实现顺序</h3><p>然后我个人建议是按照这样的顺序来写，当然不排除有不按套路出牌的。</p>
<h4 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h4><p>我们先实现一个空间配置器，用于管理内存的分配回收，对象的构造析构。毕竟你要数据，就要给内存它放。有些童鞋可能会看到 SGI STL 中的实现，用的是内存池，什么自由链表，什么管理内存碎片……哦嚯听起来好x啊！我一开始也是这么做的，直到非常后来才发现这样<strong>并无卵用</strong>啊！！具体原因不在这里详细谈，只简单的讲一讲。因为用内存池很容易不释放内存还给系统，你会说不是大于xxxx bytes就调用 malloc/free 的吗？这个是这样的没错，但是还有很多是基于 node type 的容器，比如 <code>list</code> / <code>set</code> / <code>map</code> / <code>unordered_*</code> 等，而它们的 node 的大小并不是都一样的，所以不能完全复用，于是还是会分配一大堆的小内存，然后释放不了，全部都堆在池子里面。所以我原来测试的时候内存动不动就上几个G，后来实在是忍受不了内存池的破事了，于是弃用了。直接 new / delete，结果发现，性能反而好了不少……而且，现代的C++标准实现全部都是这样做的，你也不需要有什么疑虑了。因此这个部分，应该很快就可以完成。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>做完了 Allocator，我推荐先把迭代器的几种类型，以及迭代器的类型萃取呀，和 <code>advance</code>, <code>distance</code> 等常用函数。因为迭代器是算法与容器之间的“粘合剂”，无论是我们的算法还是容器，都是基于迭代器的。所以要先把迭代器的概念做出来。这里就用到了 STL 中常用的 tag 技巧，声明一些空类型，这些类型可以利用模板类型推导，来帮助我们识别我们想要的东西。标准的要求可以看 <a href="http://en.cppreference.com/w/cpp/iterator" target="_blank" rel="external">这里</a>，具体实现可以参考一下 <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/iterator#L441" target="_blank" rel="external">这里</a> 的技巧。</p>
<h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><p>然后我推荐先实现一部分基础函数，因为这一部分的函数的使用频率非常的高，要实现容器也是离不开它们的，所以如何实现好这一部分基础函数是非常关键的。主要的我列出来一些：</p>
<p>修改未初始化的空间：</p>
<ul>
<li>uninitialized_copy</li>
<li>uninitialized_copy_n</li>
<li>uninitialized_fill</li>
<li>uninitialized_fill_n</li>
<li>uninitialized_move</li>
<li>uninitialized_move_n</li>
</ul>
<p>修改已初始化的空间：</p>
<ul>
<li>copy</li>
<li>copy_backward</li>
<li>move</li>
<li>move_backward</li>
<li>fill</li>
<li>fill_n</li>
</ul>
<p>其它常用的：</p>
<ul>
<li>swap</li>
<li>min</li>
<li>max</li>
</ul>
<p>能先把这些实现出来就差不多了，还有一些在容器中也会用到的比如 <code>reverse</code>, <code>make_heap</code>, <code>sort_heap</code> 等，可以用到的时候再去实现。</p>
<p>然后你可以先尝试自己先按照自己的理解实现一遍，比如 uninitialized_copy，刚开始，思路会比较单纯，就是给 [first, last) 构造一个值，可能会写成这样（当然你可以写得更好）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function">InputIterator</span></div><div class="line"><span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span> (; first != last; ++first, ++result)</div><div class="line">		construct(*result, *first);</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而你去看看主流标准库的实现，会发现跟你的差别非常巨大！比如看 <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/memory#L3120" target="_blank" rel="external">libcxx</a> 的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="title">class</span> _<span class="title">ForwardIterator</span>&gt;</span></div><div class="line">_<span class="title">ForwardIterator</span></div><div class="line"><span class="title">uninitialized_copy</span>(_<span class="title">InputIterator</span> __<span class="title">f</span>, _<span class="title">InputIterator</span> __<span class="title">l</span>, _<span class="title">ForwardIterator</span> __<span class="title">r</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type value_type;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></div><div class="line">    _ForwardIterator __s = __r;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="keyword">for</span> (; __f != __l; ++__f, (<span class="keyword">void</span>) ++__r)</div><div class="line">            ::<span class="keyword">new</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(_VSTD::addressof(*__r))) value_type(*__f);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (; __s != __r; ++__s)</div><div class="line">            __s-&gt;~value_type();</div><div class="line">        <span class="keyword">throw</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> __r;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个 new 是什么用法？为什么要用 <code>addressof</code>？for 循环里面 <code>++__r</code> 前面为什么要有 <code>(void)</code> ？以及异常的使用。你才会发现，原来需要考虑的地方还真多。你别说，这些问题还真的是有原因的，贴两个连接：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/32680208/is-there-any-advantage-of-using-stdaddressof-function-template-instead-of-us" target="_blank" rel="external">https://stackoverflow.com/questions/32680208/is-there-any-advantage-of-using-stdaddressof-function-template-instead-of-us</a><br><a href="https://github.com/Alinshans/LCPP/blob/master/Note/other.md" target="_blank" rel="external">https://github.com/Alinshans/LCPP/blob/master/Note/other.md</a></p>
</blockquote>
<p>所以啊，遇到什么问题，首先应该自己去搜索，学会搜索是很重要的。尤其是掌握 <a href="https://stackoverflow.com" target="_blank" rel="external">stack overflow</a> 和 <a href="google.com">google</a> 的使用。</p>
<p>以上我列出来的那些函数，实现都不简单，但是你去看了某个的实现，其它的都可以照猫画瓢。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>真的是万事开头难，若不是有经验，第一次都是无从下手，或者写的很糟糕的。我们已经把一些基础的东西写好了，接下来可以实现一些容器了！</p>
<p>（未完明天更……）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有点忙，忙里抽点空出来把这个系列给补完吧！&lt;/p&gt;
&lt;h3 id=&quot;前置要求&quot;&gt;&lt;a href=&quot;#前置要求&quot; class=&quot;headerlink&quot; title=&quot;前置要求&quot;&gt;&lt;/a&gt;前置要求&lt;/h3&gt;&lt;p&gt;首先，我再强调一遍，你至少要达到以下的要求：&lt;/p&gt;
&lt;ul&gt;
    
    </summary>
    
      <category term="自己实现STL" scheme="http://www.alinshans.com/categories/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0STL/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
      <category term="STL" scheme="http://www.alinshans.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>如何自己写一个STL(上)</title>
    <link href="http://www.alinshans.com/2017/08/20/p1708201/"/>
    <id>http://www.alinshans.com/2017/08/20/p1708201/</id>
    <published>2017-08-20T08:09:12.000Z</published>
    <updated>2017-08-20T13:21:49.748Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我的一个小项目 <a href="https://github.com/Alinshans/MyTinySTL" target="_blank" rel="external">MyTinySTL</a> 发布了 <code>v2.0.0</code> 版本，宣布这个项目告一段落。这个项目从去年暑假开始动工，至今已经过了一年多了，期间完成过多次重构，这一次算是第三次重构，进行了非常多的修改。可以看到，提交数已经超过 1000，当然我没有特地凑这个数字，而是我最后一次 merge 之后，刚好就是一千了！而代码量，现存下来的不是很多，2W 余行，但是期间 debug 过的代码量，远远超过这个数字。所以我也不会去求 star，但是能给就最好了！(〃’▽’〃)</p>
<p><img src="http://i4.bvimg.com/594413/bd9ba95504a190fd.jpg" alt="MyTinySTL"></p>
<p><img src="http://i4.bvimg.com/594413/af4dd627a3514c3c.jpg" alt="MyTinySTL"></p>
<p>其实这期间，有人向我反馈过，我有没有一些笔记什么的。然而一直没有什么时间做。我很高兴能够有人看一眼我的拙作（其实我收到的反馈也只有两个人），但更重要的是我自己的收获。所以现在，我基本也可以弃掉这个坑，去学习其它的东西了，就来说一些自己实现一个 tinystl 的感想吧！</p>
<h3 id="为什么要自己实现一个-STL"><a href="#为什么要自己实现一个-STL" class="headerlink" title="为什么要自己实现一个 STL"></a>为什么要自己实现一个 STL</h3><p>这个问题在不同时候、不同的人身上，会有不同的意义。对于我个人而言，当初我的想法是什么呢？其实我很早之前就已经接触过和自学过 C++ 了，但那毕竟是太小的时候，以至于很多东西都不懂，所以也可以说根本不会。但也不是完全没有帮助，对我的帮助就是没有 “如何入门C++” 这一说。因为基本的语法之类的我也知道，只是不明白为什么这样写。所以等我到了大学，我只花了两天时间把几年前的一本 C++ 入门书翻一翻，就大概复习了一遍 C++ 的基本语法了。当然，书是 09 年买的，所以那个时候还没有 C++11，我也不会模板。所以自然跟很多初学者会产生同样的疑问：<strong>C++ 能做什么？</strong></p>
<p>然后大一的时候，练习过一些竞赛题，用 C++ 写。那时候就只知道，C++ 有个东西，叫 STL。<code>#include &lt;algorithm&gt;</code> 后你可以直接用 <code>sort</code>，不用自己写；<code>#include &lt;vector&gt;</code> 后你可以用 <code>vector</code>，还不需要管它的长度；<code>#include &lt;map&gt;</code> 之后可以用 <code>map</code>，相当于自己用两个 raw array 来模拟……但是，为什么就可以用呢？为什么要写成 <code>vector&lt;int&gt;</code> 呢？这个<code>&lt;int&gt;</code>有什么用呢？……那时候我还真不懂，连模板都没听过。</p>
<p>后来，我希望找一些简单的练手项目，来练习一下 C++。但是好多人提的练手项目，我都看不懂，不知道他们在说什么，不知道初学者会不会也有这样的感受。然后我就看到有一个人说：实现一个 <code>tinystl</code> 。哎，这个我好像知道，然后看了看别人附上的链接，里面有 <code>Vecot</code>，有 <code>List</code>，emmmmmm…我当时对 STL 的理解就是，把数据结构封装成库了嘛，就想着数据结构还是能看懂的，而且也希望了解一下 C++ 里面那些玩意儿是怎么实现的，立马就决定了 —— 就写一个 tinystl 了！</p>
<h3 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h3><p>决定好了，怎么开始呢？我看到很多人都提到一本书 —— 《STL源码剖析》，于是我自然也去买了这本书来看。当然现在让我推荐，我对这本书持保留态度。确实这本书很老，而且用的是 SGI 的实现。但是这本书是让我认识到了什么是 STL，STL 的构成等等等等。但是对于现在入门 C++ 都有什么 Primer 什么 Plus 什么 5 的，那么好的资源，应该这些东西都懂，根本不需要再看那本书了。书中提到，还需要一些模板的基础知识，所以我就在网上学习了一下 C++ 模板的基础知识，也是那种很零碎的一篇一篇博客，但知识够用了，因为 STL 中用到的技巧并不复杂。当然现在让我推荐 C++ 模板的教程的话，我自然会安利一波空大（空明流转）的这个 <a href="https://github.com/wuye9036/CppTemplateTutorial" target="_blank" rel="external">CppTemplateTutorial</a>，还有我的 PR 呢，只不过空大太忙了没时间看。然后有了基础了解之后，就差不多可以动手了。当然这一篇文章我不会开始讲如何去写，我想先说说我个人的感受。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>说实话，tinystl 的规模可以说是要大就大，要小就小。小的可以很简单，大的可以很复杂。刚开始我也没想过有多少，也没想过要写得完善，没想到最后却跟这辣鸡标准库越来越接近…比如接口，会修改得跟标准一致，以及异常安全保证，也会尽量遵守标准。当然这也不全是坏事，因为你去实现一遍，你就能感受到很多设计极其不合理的地方…这样你再喷的时候才能<strong>有理有据</strong>。<br>当然，实现过程免不了 “借鉴” 或者 “抄袭”，毕竟很多东西让你从 0 到 1，是很难做到的。但是你有了这个从 0 到 1 的基础之后，再往后 从 1 到 2 甚至到 n (n &gt; 2)，都是容易得多的。比如你多写几个 algorithm 里的函数，你就会发现套路其实都差不多的，大部分函数你都可以独自写出。只有少部分需要用到智商。容器的话，数据结构间的差异还是蛮大的（不要扯什么 set/map，我说的不是这个意思），所以具体实现有许多不同。但整体框架都保持一致，都是 constructor, destructor, operator=，迭代器相关、容量相关、插入删除相关，有些可能还有容器特有的操作等等。<br>所以不要担心它多，担心它难，只要开始去做，把开始的工作做好，剩下来的就是不断的糊各种各样的东西而已。当然，非常重要的一点，一定要在做之前对各种数据结构的原理了然于心。</p>
<h3 id="有没有用"><a href="#有没有用" class="headerlink" title="有没有用"></a>有没有用</h3><p>也会有人说，现在学 C++ 的造 STL 泛滥，各种 github 上抄来抄去，有什么用？当然啦，有没有用，这是很难讲的。你觉得有，可能就有；你觉得没有，也未必没有。也要考虑你出于什么目的，比如你是一个可以独自用 C++ 造出一个什么高性能高精度运算库，什么高性能 DB，什么游戏引擎的，对什么 template，什么 tag dispatch，什么 SFINAE 等技法早就烂熟于心的，你说造一个 tinystl 干嘛？别人根本就不屑用标准库的了，都有自己的一套。而如果说你是想提升 C++ 技能，学习 C++ 技巧，造一个 tinystl 其实并没有用到太多的技巧，讲真，大部分时间都是去堆砌、堆砌、堆砌，然后找 bug、找 bug、找 bug。<br>那么你说，造它有什么用呢？我个人觉得，学习不能抱着太强的目的，因为学习的过程本身就是未知的、曲折的、探索的，其中很有可能伴着失败，你要是抱着很强目的心去学习，学不到的，还有可能会走火入魔（雾）。<br>而于我而言，我完成这个，对我的帮助还蛮大。但主要不是在 STL 这一块。因为我在写这个之前，很少用多个头文件，源文件这样的，都是一个文件全搞定。所以这可以说是第一个“工程”类的项目了吧？所以我学到了很多代码结构，工程方面的东西。包括但不限于头文件 include 保护、代码规范等。说真的在代码规范这方面我为此看了非常多，包括但不限于 Google C++ 代码风格、LLVM 代码风格等。尽量向好的代码看齐。也为此进行过多次重构。第二，接触到了许多工具，比如 git，camke，ci 等。刚开始我也不会用 github 的，在本地写了，然后在网页上打开去一个一个的修改。后来我才知道这是个多么蠢的姿势…然后是接触到 cmake，我承认我到现在也不完全会用，但已经比之前好多了…还有 ci，也是最开始根本不会用，文档看不懂，折腾了很久，到现在勉强可以使用。第三，了解到很多概念。比如跨平台跨编译器，编译器版本，编译参数等等非常多的东西。为了能测试在其它平台上的运行，还折腾了一段时间双系统，linux 什么的。以前只会在 VS 里面 Ctrl + F5，现在至少可以用 <code>g++ test.cpp -O2 -std=c++11 -Wall -Wextra  -Wno-sign-compare</code> 这类的东西而且明确的知道每个参数的意义。<br>所以，这期间其实是很长的一段时间，不一定都是因为我做这个我才了解，也有可能做别的我也能了解，但有些我知道了我就有一个东西让我去用上。因此我认为我造一个 tinystl 就是有用的。因为它培养了我很多良好的工程习惯，让我后面在写各种东西的时候，能够比较轻松自如，知道怎么去着手。<br>所以如果你已经有过这些经验，你去造一个 tinystl，你可能不会像我一样收获那么多，但如果你想做，那就做呗，反正标准库又不好用（逃</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结其实都在上面的话里，让我再总结一遍，那就几句话吧：</p>
<ul>
<li>给个 star</li>
<li>我不懂模板，想搞清楚 STL 的实现，所以就做了</li>
<li>如果你想做，你需要了解过 STL，使用过 STL，并对其中的数据结构的<strong>原理</strong>非常熟悉</li>
<li>“抄袭” 很正常啊</li>
<li>你觉得有用就有用，你想做就做，管别人怎么说干嘛</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，我的一个小项目 &lt;a href=&quot;https://github.com/Alinshans/MyTinySTL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyTinySTL&lt;/a&gt; 发布了 &lt;code&gt;v2.0.0&lt;/code&gt; 版本，宣布这个项
    
    </summary>
    
      <category term="自己实现STL" scheme="http://www.alinshans.com/categories/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0STL/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
      <category term="STL" scheme="http://www.alinshans.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（五）</title>
    <link href="http://www.alinshans.com/2017/07/28/p1707281/"/>
    <id>http://www.alinshans.com/2017/07/28/p1707281/</id>
    <published>2017-07-28T10:56:34.000Z</published>
    <updated>2017-07-28T17:03:41.723Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有更新了。因为最近还在重构 <a href="https://github.com/Alinshans/MyTinySTL" target="_blank" rel="external">MyTinySTL</a>，过程还是挺艰辛的 =.= 重构了一遍 <a href="https://github.com/Alinshans/MyTinySTL/blob/master/MyTinySTL/rb_tree.h" target="_blank" rel="external">rb_tree</a>，整整看了几天代码，各种博客和 paper 才开始下得了手。结果好不容易把 <a href="https://github.com/Alinshans/MyTinySTL/blob/master/MyTinySTL/rb_tree.h" target="_blank" rel="external">rb_tree</a> 给重构完，又发现了 <a href="https://github.com/Alinshans/MyTinySTL/blob/master/MyTinySTL/deque.h" target="_blank" rel="external">deque</a> 出了内存管理的问题…又重构了一遍。</p>
<p>看到以前写的代码，想推翻重来是很正常的。要么就是以前写得实在是太好了，不需要重构，代码清清楚楚，性能完全压榨。要么就是以前水平太低，现在看不下去。但前者的情况还是比较少的嘛。本来我写这个 <a href="https://github.com/Alinshans/MyTinySTL" target="_blank" rel="external">MyTinySTL</a>，只是拿来玩玩的，结果被喷不少，结果就是现在越来越接近标准库。。</p>
<p>当然前面讲的这些都不是重点，而是我一直有一个错误的做法，而且还一直没发现。就是看我以前写的东西，会有很多函数，前面有两个下划线 <code>__</code>，比如私有成员函数、辅助函数等，比如以下一张选自曾经的 <code>deque</code>：<br><img src="http://i2.tiimg.com/594413/1c83b889bd53e9ac.png" alt="Code"><br>然后偶然间，被某大神看到，喷了一顿。因为<strong>这不是合法的行为</strong>，见 <a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">n4659</a> 5.10.3 节：</p>
<blockquote>
<p>3 In addition, some identiﬁers are reserved for use by C++ implementations and shall not be used otherwise; no diagnostic is required.<br>(3.1) – Each identiﬁer that contains a double underscore __ or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.<br>(3.2) – Each identiﬁer that begins with an underscore is reserved to the implementation for use as a name in the global namespace. </p>
</blockquote>
<p><strong><code>__</code> 开头的，或者 <code>_</code>加一个大写字母为开头的，都是为编译器实现作保留的</strong>，反正我们这些凡人，要是不是做编译器的，那老老实实别用，否则后果自负。<br>其实我也是受了某本书的影响，所以才这么用的。现在慢慢长大了，就一点一点要把以前的东西改过来。要是有机会，再慢慢记录一下这个过程吧！<br>还要继续写 <strong>bug</strong>，早日挖出一个巨坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有更新了。因为最近还在重构 &lt;a href=&quot;https://github.com/Alinshans/MyTinySTL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyTinySTL&lt;/a&gt;，过程还是挺艰辛的 =.= 重构了一遍 &lt;a href
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://www.alinshans.com/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 笔记（三）：验证码生成</title>
    <link href="http://www.alinshans.com/2017/07/10/p1707101/"/>
    <id>http://www.alinshans.com/2017/07/10/p1707101/</id>
    <published>2017-07-10T06:03:06.000Z</published>
    <updated>2017-07-10T08:33:16.572Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，我在刚接触 <code>OpenCV</code> 的第一天，就想着做一个验证码识别程序。这一篇呢，先讲验证码生成（因为验证码识别还不会做），毕竟生成比识别简单多了嘛！而且昨天刚刚学习了一些 <code>Mat</code> 的知识，生成了许多图像，那么今天就来尝试一下如何生成验证码吧！</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我想的生成验证码的思路非常简单，就是一张小图片，然后放一些随机的数字或字母上去，然后再加上一点噪点之类的干扰。那么关键步骤就是如何把文本放上去了。<br>一般遇到这种问题，我们就会去查阅文档。不过根据我多年的经验，因为我用的是 <code>VS</code>，我就直接先在 <code>IDE</code> 里敲了一下 <code>text</code>，果然…在弹出的提示中我就发现了一个 <code>putText</code>。然后我就敲下括号，就看到了这个函数声明大概长这样：<br><img src="http://i2.kiimg.com/594413/c4daed24aa7cae1b.png" alt="VS"><br>嗯..看到 <code>renders the specified text string in the image</code> 然后我就确定了没错！这就是我想要的函数！<br>接着就可以在 <a href="http://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576" target="_blank" rel="external">官方文档</a> 找到这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> cv::putText (InputOutputArray img,</div><div class="line">                  <span class="keyword">const</span> String &amp;   text,</div><div class="line">                  Point            org,</div><div class="line">                  <span class="keyword">int</span>              fontFace,</div><div class="line">                  <span class="keyword">double</span>           fontScale,</div><div class="line">                  Scalar           color,</div><div class="line">                  <span class="keyword">int</span>              thickness = <span class="number">1</span>,</div><div class="line">                  <span class="keyword">int</span>              lineType = LINE_8,</div><div class="line">                  <span class="keyword">bool</span>             bottomLeftOrigin = <span class="literal">false</span> </div><div class="line">	)</div></pre></td></tr></table></figure></p>
<p>参数确实有点多啊，不过看完它给的参数说明，就都可以理解了：</p>
<ul>
<li><code>img</code>    Image.</li>
<li><code>text</code>    Text string to be drawn.</li>
<li><code>org</code>    Bottom-left corner of the text string in the image.</li>
<li><code>fontFace</code>    Font type, see cv::HersheyFonts.</li>
<li><code>fontScale</code>    Font scale factor that is multiplied by the font-specific base size.</li>
<li><code>color</code>    Text color.</li>
<li><code>thickness</code>    Thickness of the lines used to draw a text.</li>
<li><code>lineType</code>    Line type. See the line for details.</li>
<li><code>bottomLeftOrigin</code>    When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner. </li>
</ul>
<p>然后我又在中文网上看到了 <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/random_generator_and_text/random_generator_and_text.html" target="_blank" rel="external">这个</a>，恰好，想要的东西都齐了。<code>RNG</code> 是 <code>OpenCV</code> 的随机数字生成器，刚好就可以用来完成我们的工作。可以在 <a href="http://docs.opencv.org/master/d1/dd6/classcv_1_1RNG.html" target="_blank" rel="external">这里</a> 查看它的文档。我们主要用到的就是它的 <code>uniform</code> 函数，这个函数可以生成指定范围内分布均匀的随机数。</p>
<h3 id="开始绘图"><a href="#开始绘图" class="headerlink" title="开始绘图"></a>开始绘图</h3><p>首先，我们先绘制出一张背景图，我也不确定要多大，先随便给个数。然后构造我们的随机数生成器，我发现如果构造时那个值不变，运行的时候它每次随机的还是一样的，所以就取了当前时间来构造 <code>RNG</code>。然后随机初始化一张背景，我把数字调大一点，是为了让背景色更亮。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line">using namespace cv;</div><div class="line"></div><div class="line">const int width = 150;</div><div class="line">const int height = 100;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  // 取当前时间来构造 RNG</div><div class="line">  std::time_t t;</div><div class="line">  t = time(NULL);</div><div class="line">  RNG rng(static_cast&lt;int64_t&gt;(t));</div><div class="line"></div><div class="line">  Scalar bg(rng.uniform(200,255), rng.uniform(233, 255), rng.uniform(233, 255));</div><div class="line">  Mat vcode(height, width, CV_8UC3, bg);</div><div class="line">  imshow("vcode", vcode);</div><div class="line">  waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时候我们就得到一个背景图，当然每次运行都是不一样的：<br><img src="http://i4.piimg.com/594413/f8e8ead2671ff771.png" alt="VCODE"></p>
<h3 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h3><p>接着，对照着 <code>putText</code> 的参数，我们写一个函数 <code>generateCode</code> 用于生成验证码。<code>putText</code> 函数里需要用到文本字符串及文本颜色，这两个值也应该是随机的，于是我们先写两个辅助函数 <code>randomText</code> 和 <code>randomColor</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">randomText</span><span class="params">(RNG&amp; rng)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* text[] = &#123;</div><div class="line">    <span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,</div><div class="line">    <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>,<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>,<span class="string">"m"</span>,<span class="string">"n"</span>,</div><div class="line">    <span class="string">"o"</span>,<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>,<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>,</div><div class="line">    <span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"J"</span>,<span class="string">"K"</span>,<span class="string">"L"</span>,<span class="string">"M"</span>,<span class="string">"N"</span>,</div><div class="line">    <span class="string">"O"</span>,<span class="string">"P"</span>,<span class="string">"Q"</span>,<span class="string">"R"</span>,<span class="string">"S"</span>,<span class="string">"T"</span>,<span class="string">"U"</span>,<span class="string">"V"</span>,<span class="string">"W"</span>,<span class="string">"X"</span>,<span class="string">"y"</span>,<span class="string">"Z"</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> text[rng.uniform(<span class="number">0</span>, <span class="number">62</span>)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">Scalar <span class="title">randomColor</span><span class="params">(RNG&amp; rng)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> icolor = rng.uniform(<span class="number">1</span> &lt;&lt; <span class="number">16</span>, <span class="number">1</span> &lt;&lt; <span class="number">20</span>);</div><div class="line">  <span class="keyword">return</span> Scalar(icolor &amp; <span class="number">255</span>, (icolor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>, (icolor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们就先假定生成的验证码中包含了四个数字或字母，用一个循环依次生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateCode</span><span class="params">(Mat&amp; image, RNG&amp; rng)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 生成的数字字母不断往右移</span></div><div class="line">    Point org;</div><div class="line">    org.x = <span class="number">20</span> * i + <span class="number">5</span> + rng.uniform(<span class="number">-3</span>,<span class="number">3</span>);</div><div class="line">    org.y = <span class="number">30</span> + rng.uniform(<span class="number">-5</span>, <span class="number">5</span>);</div><div class="line"></div><div class="line">    putText(image, randomText(rng), org, FONT_ITALIC,</div><div class="line">            rng.uniform(<span class="number">0.5</span>,<span class="number">0.7</span>), randomColor(rng), rng.uniform(<span class="number">2</span>,<span class="number">3</span>), LINE_8);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果还不明白 <code>putText</code> 中参数的意义，就仔细去阅读文档。而关于 <code>putText</code> 里的参数是怎么来的，其实都是调出来的，一点一点试，调到满意为止 =v= 我们暂时先这样，然后在主函数里加上这个函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  // 取当前时间来构造 RNG</div><div class="line">  std::time_t t;</div><div class="line">  t = time(NULL);</div><div class="line">  RNG rng(static_cast&lt;int64_t&gt;(t));</div><div class="line"></div><div class="line">  // 生成背景图</div><div class="line">  Scalar bg(rng.uniform(200,255), rng.uniform(233, 255), rng.uniform(233, 255));</div><div class="line">  Mat vcode(height, width, CV_8UC3, bg);</div><div class="line"></div><div class="line">  // 生成验证码</div><div class="line">  generateCode(vcode, rng);</div><div class="line"></div><div class="line">  imshow("vcode", vcode);</div><div class="line"></div><div class="line">  waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行的效果大概是这样：<br><img src="http://i1.buimg.com/594413/71919dd4826ff80c.png" alt="VCODE"><br>看起来挺简单吧！</p>
<h3 id="加入干扰"><a href="#加入干扰" class="headerlink" title="加入干扰"></a>加入干扰</h3><p>我们看到的验证码，可不仅仅是像我们刚刚生成的那样，往往还会一些“噪点”，比如加入一些乱七八糟的点或线。我们同样也要做这个工作。我们还可以在 <a href="http://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html" target="_blank" rel="external">这里</a> 找到很多绘制的函数，这可以帮助我们完成这项工作。<br>说是“噪点”，但实际上一个像素点实在是太小了，所以我使用的是一个很小的圆来代替，对应的函数是 <code>circle</code>，可以看 <a href="http://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670" target="_blank" rel="external">这里</a> 的说明。</p>
<p>于是我们写一个 <code>interfere</code> 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">interfere</span><span class="params">(Mat&amp; image, RNG&amp; rng)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 加入圆形干扰</span></div><div class="line">  Point center;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rng.uniform(<span class="number">30</span>, <span class="number">50</span>); ++i)</div><div class="line">  &#123;</div><div class="line">    center.x = rng.uniform(<span class="number">0</span>, width);</div><div class="line">    center.y = rng.uniform(<span class="number">0</span>, height);</div><div class="line">    circle(image, center, rng.uniform(<span class="number">0</span>,<span class="number">2</span>), randomColor(rng), rng.uniform(<span class="number">1</span>,<span class="number">3</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把这个函数放在 <code>main</code> 函数的生成验证码后面，然后运行一下，效果大概如下：<br><img src="http://i2.kiimg.com/594413/faae62f376b90881.png" alt="VCODE"></p>
<p>这样子看起来不够，我们还可以加入一些随机线条，我使用的是 <code>ellipse</code> 这个函数，它是用于生成椭圆的，我们可以用来生成一些曲线，可以在 <a href="http://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69" target="_blank" rel="external">这里</a> 查看文档说明。<br>然后我们在 <code>interfere</code> 里加入这个部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">interfere</span><span class="params">(Mat&amp; image, RNG&amp; rng)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 加入圆形干扰</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="comment">// 加入线条干扰</span></div><div class="line">  Size axes;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rng.uniform(<span class="number">8</span>, <span class="number">12</span>); ++i)</div><div class="line">  &#123;</div><div class="line">    center.x = rng.uniform(<span class="number">0</span>, width);</div><div class="line">    center.y = rng.uniform(<span class="number">0</span>, height);</div><div class="line">    axes.width = rng.uniform(<span class="number">20</span>, <span class="number">50</span>);</div><div class="line">    axes.width = rng.uniform(<span class="number">20</span>, <span class="number">50</span>);</div><div class="line">    <span class="keyword">double</span> angle = rng.uniform(<span class="number">0</span>, <span class="number">180</span>);</div><div class="line">    ellipse(image, center, axes, angle,</div><div class="line">            angle - rng.uniform(<span class="number">0</span>, <span class="number">10</span>), angle + rng.uniform(<span class="number">0</span>, <span class="number">10</span>),</div><div class="line">            randomColor(rng), rng.uniform(<span class="number">0</span>, <span class="number">4</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次运行一下，结果大概像这样：<br><img src="http://i1.buimg.com/594413/90a28bec78b360f4.png" alt="VCODE"></p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>到这里我们基本就“完成了”我们丑陋了验证码生成，其实这是非常简陋的。我们还可以自己做更多的尝试，试试其他函数，以及调参。最终，经过再一次的修改，完整代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line">using namespace cv;</div><div class="line"></div><div class="line">const int width = 60;</div><div class="line">const int height = 30;</div><div class="line">const int code_number = 4;</div><div class="line"></div><div class="line">String randomText(RNG&amp; rng)</div><div class="line">&#123;</div><div class="line">  static char* text[] = &#123;</div><div class="line">    "0","1","2","3","4","5","6","7","8","9",</div><div class="line">    "a","b","c","d","e","f","g","h","i","j","k","l","m","n",</div><div class="line">    "o","p","q","r","s","t","u","v","w","x","y","z",</div><div class="line">    "A","B","C","D","E","F","G","H","I","J","K","L","M","N",</div><div class="line">    "O","P","Q","R","S","T","U","V","W","X","y","Z"</div><div class="line">  &#125;;</div><div class="line">  return text[rng.uniform(0, 62)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Scalar randomColor(RNG&amp; rng)</div><div class="line">&#123;</div><div class="line">  int icolor = rng.uniform(1 &lt;&lt; 16, 1 &lt;&lt; 20);</div><div class="line">  return Scalar(icolor &amp; 255, (icolor &gt;&gt; 8) &amp; 255, (icolor &gt;&gt; 16) &amp; 255);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在 image 上增加噪点</div><div class="line">void interfere(Mat&amp; image, RNG&amp; rng)</div><div class="line">&#123;</div><div class="line">  // 加入圆形干扰</div><div class="line">  Point center;</div><div class="line">  for (int i = 0; i &lt; rng.uniform(50, 80); ++i)</div><div class="line">  &#123;</div><div class="line">    center.x = rng.uniform(0, width);</div><div class="line">    center.y = rng.uniform(0, height);</div><div class="line">    circle(image, center, 0, randomColor(rng), 1);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 加入线条干扰</div><div class="line">  Size axes;</div><div class="line">  for (int i = 0; i &lt; rng.uniform(10, 20); ++i)</div><div class="line">  &#123;</div><div class="line">    center.x = rng.uniform(0, width);</div><div class="line">    center.y = rng.uniform(0, height);</div><div class="line">    axes.width = rng.uniform(20, 50);</div><div class="line">    axes.width = rng.uniform(20, 50);</div><div class="line">    double angle = rng.uniform(0, 180);</div><div class="line">    ellipse(image, center, axes, angle,</div><div class="line">            angle - rng.uniform(0, 10), angle + rng.uniform(0, 10),</div><div class="line">            randomColor(rng), rng.uniform(0, 2));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在 image 上生成验证码</div><div class="line">void generateCode(Mat&amp; image, RNG&amp; rng)</div><div class="line">&#123;</div><div class="line">  for (int i = 0; i &lt; code_number; i++)</div><div class="line">  &#123;</div><div class="line">    // 生成的数字字母不断往右移</div><div class="line">    Point org;</div><div class="line">    org.x = 13 * i + 5 + rng.uniform(-2,2);</div><div class="line">    org.y = 20 + rng.uniform(-5, 5);</div><div class="line"></div><div class="line">    putText(image, randomText(rng), org, FONT_ITALIC,</div><div class="line">            rng.uniform(0.5,0.6), randomColor(rng), rng.uniform(2,3), LINE_8);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  // 取当前时间来构造 RNG</div><div class="line">  std::time_t t;</div><div class="line">  t = time(NULL);</div><div class="line">  RNG rng(static_cast&lt;int64_t&gt;(t));</div><div class="line"></div><div class="line">  // 生成背景图</div><div class="line">  Scalar bg(rng.uniform(200,255), rng.uniform(233, 255), rng.uniform(233, 255));</div><div class="line">  Mat vcode(height, width, CV_8UC3, bg);</div><div class="line"></div><div class="line">  // 加入干扰</div><div class="line">  interfere(vcode, rng);</div><div class="line"></div><div class="line">  // 生成验证码</div><div class="line">  generateCode(vcode, rng);</div><div class="line"></div><div class="line">  imshow("vcode", vcode);</div><div class="line"></div><div class="line">  waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是生成的验证码的展示图：<br><img src="http://i2.kiimg.com/594413/95866c3f32337cc1.png" alt="vcode1"> <img src="http://i2.kiimg.com/594413/4042b9110fc9c249.png" alt="vcode2"> <img src="http://i2.kiimg.com/594413/06cbcc68956d0929.png" alt="vcode3"> <img src="http://i2.kiimg.com/594413/7d75ef0bc2dcd138.png" alt="vcode4"> <img src="http://i2.kiimg.com/594413/77a640146f18486c.png" alt="vcode5"> <img src="http://i2.kiimg.com/594413/37d54dbf56377f81.png" alt="vcode6"><br>还可以吧！有模有样了 （￣︶￣）↗</p>
<p>去研究验证码识别了 <em>(:з」∠)</em> ，希望下一篇文章能早日出来~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话，我在刚接触 &lt;code&gt;OpenCV&lt;/code&gt; 的第一天，就想着做一个验证码识别程序。这一篇呢，先讲验证码生成（因为验证码识别还不会做），毕竟生成比识别简单多了嘛！而且昨天刚刚学习了一些 &lt;code&gt;Mat&lt;/code&gt; 的知识，生成了许多图像，那么今天就来尝试
    
    </summary>
    
      <category term="opencv" scheme="http://www.alinshans.com/categories/opencv/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
      <category term="opencv" scheme="http://www.alinshans.com/tags/opencv/"/>
    
      <category term="visual studio" scheme="http://www.alinshans.com/tags/visual-studio/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 笔记（二）：Mat 类初探</title>
    <link href="http://www.alinshans.com/2017/07/09/p1707091/"/>
    <id>http://www.alinshans.com/2017/07/09/p1707091/</id>
    <published>2017-07-09T03:08:55.000Z</published>
    <updated>2017-07-09T15:09:48.394Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>OpenCV</code> 的很多跟图像有关的东西里，都离不开一样东西 —— <code>Mat</code> 类。读一张图片，返回的是一个 <code>Mat</code>，显示一张图片，用的也是 <code>Mat</code>。我们都知道这是一个矩阵类，但它到底是如何工作的呢？如何将一个矩阵跟各种图像、图像间关系、图像间变换等东西联系起来呢？其实我们多多少少都有一点了解，但概念又不是特别清晰。所以十分有必要去深入的探索一下这个 <code>Mat</code> 类，我们才能更有效且高效地写出想要的程序。正如我们要对 <code>STL</code> 有深入的理解才能更有效且高效的写出我们想要的程序。</p>
<h3 id="Mat-类的结构"><a href="#Mat-类的结构" class="headerlink" title="Mat 类的结构"></a>Mat 类的结构</h3><p>这里我们主要讲的是 <code>Mat</code> 类的储存结构，即用什么数据来表现一个 <code>Mat</code>。我们可以通过源码看到它的一些关键变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">Mat</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 一堆函数</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 以下是主要成员变量</span></div><div class="line">    <span class="comment">// [1]</span></div><div class="line">    <span class="comment">/*! includes several bit-fields:</span></div><div class="line">         - the magic signature</div><div class="line">         - continuity flag</div><div class="line">         - depth</div><div class="line">         - number of channels</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> flags;</div><div class="line">    <span class="comment">//! the matrix dimensionality, &gt;= 2</span></div><div class="line">    <span class="keyword">int</span> dims;</div><div class="line">    <span class="comment">//! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions</span></div><div class="line">    <span class="keyword">int</span> rows, cols;</div><div class="line">    <span class="comment">//! pointer to the data</span></div><div class="line">    uchar* data;</div><div class="line"></div><div class="line">    <span class="comment">// [2]</span></div><div class="line">    <span class="comment">//! helper fields used in locateROI and adjustROI</span></div><div class="line">    <span class="keyword">const</span> uchar* datastart;</div><div class="line">    <span class="keyword">const</span> uchar* dataend;</div><div class="line">    <span class="keyword">const</span> uchar* datalimit;</div><div class="line"></div><div class="line">    <span class="comment">// [3]</span></div><div class="line">    <span class="comment">//! interaction with UMat</span></div><div class="line">    UMatData* u;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些我只列出了主要的一些变量，并且分成三个部分：</p>
<ul>
<li>第[1]部分是与矩阵相关的一些信息，<code>flags</code> 储存了矩阵的标识、是否连续、深度、通道数等信息，<code>dims</code> 代表矩阵的维数，<code>rows</code> 和 <code>cols</code> 代表矩阵的行数与列数，<code>data</code> 是指向储存矩阵数据的指针。</li>
<li>第[2]部分是与感兴趣区域有关的信息，感兴趣区域即 ROI(Region Of Interset)。</li>
<li>第[3]部分是一个指针，指向一个 <code>UMatData</code> 类型，我们查看一下 <code>UMatData</code> 的定义，可以知道这是跟引用计数相关的。</li>
</ul>
<p><code>UMatData</code> 的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CV_EXPORTS</span> <span class="title">UMatData</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// provide atomic access to the structure</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 一些函数...</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> MatAllocator* prevAllocator;</div><div class="line">    <span class="keyword">const</span> MatAllocator* currAllocator;</div><div class="line">    <span class="keyword">int</span> urefcount;</div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line">    uchar* data;</div><div class="line">    uchar* origdata;</div><div class="line">    <span class="keyword">size_t</span> size;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> flags;</div><div class="line">    <span class="keyword">void</span>* handle;</div><div class="line">    <span class="keyword">void</span>* userdata;</div><div class="line">    <span class="keyword">int</span> allocatorFlags_;</div><div class="line">    <span class="keyword">int</span> mapcount;</div><div class="line">    UMatData* originalUMatData;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是很容易理解的：由一张图片储存成的矩阵通常不小，例如一张 1024 * 768 的三通道彩色图，储存的矩阵就占了 1024 * 768 * 3 * 1 = 2359296 Byte = 2304 KB。而 <code>OpenCV</code> 作为计算机视觉库，它就是负责处理一大堆的这些图像信息，所以经常拷贝大的图像，开销是非常大的。自然地，就采用了引用计数。<br>一个 <code>Mat</code> 的数据主要包含两个部分：矩阵头和指向像素数据的指针，矩阵头主要包含了：矩阵尺寸、存储方式、存储地址、引用计数等。每个 <code>Mat</code> 类，都会有自己的矩阵头，同时，要是通过引用计数，就可以共享同一片矩阵区域，而不用复制两片一模一样的空间啦！</p>
<h3 id="图像的储存方式"><a href="#图像的储存方式" class="headerlink" title="图像的储存方式"></a>图像的储存方式</h3><p>一般来说，一个 M x N 的图像可以由一个 M x N 的矩阵来表示。矩阵如何储存这些像素值呢？需要指定<strong>颜色空间</strong>和<strong>数据类型</strong>。<strong>颜色空间</strong>就是对指定颜色的一种编码，比如最简单的灰度空间，只有黑色跟白色，以及他们的组合可以组成不同程度的灰色。还有常见的彩色空间，可能有三种或四种的基本元素，然后由这些基本元素可以组成各种各样的颜色。<code>RGB</code>颜色空间就是最常用的彩色空间，若再加入第四个元素 <code>Alpha</code>，就可以用来表示透明度。而<strong>数据类型</strong>就是指组成颜色的这些元素的大小，最小的数据类型就是 <code>char</code>，占一个字节，如 <code>RGB</code> 颜色的元素常用 <code>unsigned char</code> 来表示，可以表示范围 0 ~ 255 的数值。当然还可以用更大的数据类型来获得更精确的颜色分辨。</p>
<p>例如，一个灰度图可由一个二维矩阵表示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">P(0,0)</th>
<th style="text-align:center">P(0,1)</th>
<th style="text-align:center">…</th>
<th style="text-align:center">P(0,N-1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P(1,0)</td>
<td style="text-align:center">P(1,1)</td>
<td style="text-align:center">…</td>
<td style="text-align:center">P(1,N-1)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">P(M-1,0)</td>
<td style="text-align:center">P(M-1,1)</td>
<td style="text-align:center">…</td>
<td style="text-align:center">P(M-1,N-1)</td>
</tr>
</tbody>
</table>
<p>P(i,j) 就表示第 i 行 j 列的像素值。<br>如果是<code>RBG</code>图像，则每个元素用三个字节表示，<strong>在 <code>OpenCV</code> 中，<code>RGB</code> 的储存顺序为 <code>BGR</code></strong> ：</p>
<table>
<thead>
<tr>
<th style="text-align:center">B(0,0)</th>
<th style="text-align:center">G(0,0)</th>
<th style="text-align:center">R(0,0)</th>
<th style="text-align:center">…</th>
<th style="text-align:center">B(0,N-1)</th>
<th style="text-align:center">G(0,N-1)</th>
<th style="text-align:center">R(0,N-1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B(1,0)</td>
<td style="text-align:center">G(1,0)</td>
<td style="text-align:center">R(1,0)</td>
<td style="text-align:center">…</td>
<td style="text-align:center">B(1,N-1)</td>
<td style="text-align:center">G(1,N-1)</td>
<td style="text-align:center">R(1,N-1)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">B(M-1,0)</td>
<td style="text-align:center">G(M-1,0)</td>
<td style="text-align:center">R(M-1,0)</td>
<td style="text-align:center">…</td>
<td style="text-align:center">B(M-1,N-1)</td>
<td style="text-align:center">G(M-1,N-1)</td>
<td style="text-align:center">R(M-1,N-1)</td>
</tr>
</tbody>
</table>
<h3 id="Mat-对象的创建"><a href="#Mat-对象的创建" class="headerlink" title="Mat 对象的创建"></a>Mat 对象的创建</h3><p><code>OpenCV</code> 为创建一个 <code>Mat</code> 类提供了很多方法，可以在 <a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html" target="_blank" rel="external">这里</a> 看到完整的构造的方法，我们列出一些常用的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Mat ()</div><div class="line">Mat (<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type)</div><div class="line">Mat (Size size, <span class="keyword">int</span> type)</div><div class="line">Mat (<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type, <span class="keyword">const</span> Scalar &amp;s)</div><div class="line">Mat (Size size, <span class="keyword">int</span> type, <span class="keyword">const</span> Scalar &amp;s)</div><div class="line">Mat (<span class="keyword">int</span> ndims, <span class="keyword">const</span> <span class="keyword">int</span> *sizes, <span class="keyword">int</span> type)</div><div class="line">Mat (<span class="keyword">int</span> ndims, <span class="keyword">const</span> <span class="keyword">int</span> *sizes, <span class="keyword">int</span> type, <span class="keyword">const</span> Scalar &amp;s)</div><div class="line">Mat (<span class="keyword">const</span> Mat &amp;m)</div></pre></td></tr></table></figure></p>
<h4 id="创建空矩阵"><a href="#创建空矩阵" class="headerlink" title="创建空矩阵"></a>创建空矩阵</h4><p>对于默认构造函数，会创建一个矩阵头，它没有像素数据，所以如果你写出下面这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Mat nul;</div><div class="line">imshow(<span class="string">"nul"</span>, nul);  <span class="comment">// running time error</span></div></pre></td></tr></table></figure></p>
<p>是会产生一个运行时的断言错误的，因为 <code>imshow</code> 要求矩阵的维数必须是二维的（构造时如果构造的是一维的，它也会自动扩展为二维的，让第二个维度的大小为 1）。</p>
<h4 id="创建二维矩阵"><a href="#创建二维矩阵" class="headerlink" title="创建二维矩阵"></a>创建二维矩阵</h4><p>对于二维的矩阵，就是要指定矩阵的行列以及矩阵数据的类型，初始值是可选的。矩阵类型的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</div></pre></td></tr></table></figure></p>
<p>其中，<code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]</code> 这个部分可以使用以下几个值之一：</p>
<ul>
<li>CV_8U</li>
<li>CV_8S</li>
<li>CV_16U</li>
<li>CV_16S</li>
<li>CV_32S</li>
<li>CV_32F</li>
<li>CV_64F</li>
</ul>
<p>而预定义的 <code>[The channel number]</code> 可以是 1、2、3、4，当然啦，如果你需要更多的通道数，也可以使用宏 <code>XXX(n)</code> 来生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CV_8UC(n)   <span class="comment">// n 通道的、无符号的、每个元素占 8 个 bit</span></div><div class="line">CV_8SC(n)   <span class="comment">// n 通道的、有符号的、每个元素占 8 个 bit</span></div><div class="line">CV_16UC(n)  <span class="comment">// n 通道的、无符号的、每个元素占 16 个 bit</span></div><div class="line">CV_16SC(n)  <span class="comment">// n 通道的、有符号的、每个元素占 16 个 bit</span></div><div class="line">CV_32SC(n)  <span class="comment">// n 通道的、有符号的、每个元素占 32 个 bit</span></div><div class="line">CV_32FC(n)  <span class="comment">// n 通道的、浮点类型、每个元素占 32 个 bit</span></div><div class="line">CV_64FC(n)  <span class="comment">// n 通道的、浮点类型、每个元素占 64 个 bit</span></div></pre></td></tr></table></figure></p>
<p>比如常用的 RGB 颜色类型是 <code>CV_8UC3</code>，表示每个像素由三个通道组成，而每个元素占 8 个 bit。<br>我们可以用 <code>cv::Scalar</code> 来指定矩阵的初值，比如 <code>Scalar(0)</code> 是一个单通道的黑色的像素，<code>Scalar(0,0,255)</code> 是一个三通道的红色的像素。于是，我们就可以用下面的代码创建一张全红的图片：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Mat red(200, 200, CV_8UC3, Scalar(0,0,255));</div><div class="line">imshow("red", red);</div></pre></td></tr></table></figure></p>
<p>效果：<br><img src="http://i1.buimg.com/594413/aacd9a2d6e345812.png" alt="Red Image"></p>
<h4 id="创建多维矩阵"><a href="#创建多维矩阵" class="headerlink" title="创建多维矩阵"></a>创建多维矩阵</h4><p>如果你需要更高维数的矩阵，它也提供了相应的构造函数，首先要指定维数，然后需要一个一维数组的指针，数组里包含了各个维度的尺寸，以及矩阵数据的类型，初始值也是可选的。例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int m[3] = &#123; 10,10,10 &#125;;</div><div class="line">Mat mat(3, m, CV_8UC1, Scalar(0));</div></pre></td></tr></table></figure></p>
<p>以上代码创建了一个 10 x 10 x 10 的三维矩阵，你仍然可以对它做矩阵运算，但是不能使用诸如 <code>imshow</code> 等函数了，因为必须的二维的图像才能显示出来 ^_^<br>在 <a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html" target="_blank" rel="external">这里</a> 的 <code>Detailed Description</code> 有一句话：</p>
<blockquote>
<p>It passes the number of dimensions =1 to the Mat constructor but the created array will be 2-dimensional with the number of columns set to 1. So, Mat::dims is always &gt;= 2 (can also be 0 when the array is empty).</p>
</blockquote>
<p>其实这就是在上面提到的。</p>
<h4 id="从函数返回值获取"><a href="#从函数返回值获取" class="headerlink" title="从函数返回值获取"></a>从函数返回值获取</h4><p><code>OpenCV</code> 中有很多函数，它们的返回值是 <code>Mat</code>，我们可以通过复制构造函数或赋值操作符来得到这样的对象，如我们常用的 <code>imread</code> 函数。还有许多常用的函数，现在就举一些例子。</p>
<h5 id="create"><a href="#create" class="headerlink" title="create"></a>create</h5><p>这是 <code>Mat</code> 的一个重要的成员函数，它有以下四种签名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span> <span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type)</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">create</span> <span class="params">(Size size, <span class="keyword">int</span> type)</span></div><div class="line"><span class="keyword">void</span> <span class="title">create</span> <span class="params">(<span class="keyword">int</span> ndims, <span class="keyword">const</span> <span class="keyword">int</span> *sizes, <span class="keyword">int</span> type)</span></div><div class="line"><span class="keyword">void</span> <span class="title">create</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; &amp;sizes, <span class="keyword">int</span> type)</span></div></pre></td></tr></table></figure></p>
<p>跟构造函数很类似，就是不能指定初始值。为什么说它重要呢？因为有了它，就可以我们就可以很方便、轻易的写一些函数，比如官方的 <a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a55ced2c8d844d683ea9a725c60037ad0" target="_blank" rel="external">这个例子</a> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Mat color;</div><div class="line">...</div><div class="line">Mat gray;</div><div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div></pre></td></tr></table></figure></p>
<p>你不再需要去关心为输出的对象构造好行与列，因为这些函数都会调用 <code>create</code> 这个函数。就像它所说的一样，调用 <code>create</code> 时会经过以下的步骤：</p>
<ol>
<li>If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling Mat::release.</li>
<li>Initialize the new header.</li>
<li>Allocate the new data of total()*elemSize() bytes.</li>
<li>Allocate the new, associated with the data, reference counter and set it to 1.</li>
</ol>
<p>当创建的新对象的尺寸与原来的不同时，才会重新分配新的空间。</p>
<h5 id="operator"><a href="#operator" class="headerlink" title="operator()"></a>operator()</h5><p><code>Mat</code> 类重载了 <code>operator()</code> 操作符，以便于获取图像的一部分（感兴趣区域）。它具有以下四种签名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">operator</span><span class="params">()</span> <span class="params">(Range rowRange, Range colRange)</span> <span class="keyword">const</span></span></div><div class="line">Mat <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Rect &amp;roi)</span> <span class="keyword">const</span></div><div class="line">Mat <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Range *ranges)</span> <span class="keyword">const</span></div><div class="line">Mat <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; Range &gt; &amp;ranges)</span> <span class="keyword">const</span></div></pre></td></tr></table></figure></p>
<p>如通过以下代码来获取一个图像的感兴趣区域：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Mat A = imread(<span class="string">"opencv.jpg"</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 以下两种写法等效</span></div><div class="line">Mat B = A(Range(<span class="number">0</span>,<span class="number">100</span>),Range(<span class="number">20</span>,<span class="number">200</span>));</div><div class="line"><span class="comment">// Mat B = A(Rect(20, 0, 180, 100));</span></div><div class="line"></div><div class="line">imshow(<span class="string">"A"</span>, A);</div><div class="line">imshow(<span class="string">"C"</span>, B);</div></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="http://i4.piimg.com/594413/2cb4acd55f851052.png" alt="Result"></p>
<h3 id="复制-Mat"><a href="#复制-Mat" class="headerlink" title="复制 Mat"></a>复制 <code>Mat</code></h3><p>因为 <code>Mat</code> 使用了引用计数，当你使用复制构造或赋值操作符的时候，它们实际上只是把矩阵数据的指针指向了相同的地址，共用同一片内存，所以对任意一个 <code>Mat</code> 对象做修改，也会影响到其它指向相同矩阵数据区域的对象（如果有）。我们运行一下以下这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  Mat A = imread(<span class="string">"opencv.jpg"</span>, <span class="number">1</span>), C;</div><div class="line"></div><div class="line">  <span class="comment">// 复制构造 与 赋值操作符</span></div><div class="line">  <span class="function">Mat <span class="title">B</span><span class="params">(A)</span></span>;</div><div class="line">  C = A;</div><div class="line"></div><div class="line">  <span class="comment">// 显示三个图像</span></div><div class="line">  imshow(<span class="string">"A1"</span>, A);</div><div class="line">  imshow(<span class="string">"B1"</span>, B);</div><div class="line">  imshow(<span class="string">"C1"</span>, C);</div><div class="line"></div><div class="line">  <span class="comment">// 对 A 进行归一化模糊后，再显示三个图像</span></div><div class="line">  blur(A, A, Size(<span class="number">9</span>, <span class="number">9</span>));</div><div class="line">  imshow(<span class="string">"A2"</span>, A);</div><div class="line">  imshow(<span class="string">"B2"</span>, B);</div><div class="line">  imshow(<span class="string">"C2"</span>, C);</div><div class="line"></div><div class="line">  waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="http://i4.piimg.com/594413/a6fd2420123c9ef4.png" alt="Result"><br>我们可以看到，我们对 A 进行了模糊操作，而 B 与 C 也同时“变得”模糊了！这里加了个引号，是因为它们仨本身就是共用了同一个矩阵数据呀！当然是相同的啦！<strong>注意：即使是用一个矩阵的一部分去构造另一个矩阵，它们的矩阵数据的指针指向的也是同一片区域</strong>。也就是说，对原图像的改变，或对部分图像的改变，都会使矩阵本身的数据改变。例如我们对部分进行模糊处理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Mat A = imread(<span class="string">"opencv.jpg"</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">Mat B = A(Range(<span class="number">0</span>,<span class="number">100</span>),Range(<span class="number">20</span>,<span class="number">200</span>));</div><div class="line"></div><div class="line">imshow(<span class="string">"A"</span>, A);</div><div class="line">imshow(<span class="string">"B"</span>, B);</div><div class="line"></div><div class="line"><span class="comment">// 对部分图像进行模糊处理</span></div><div class="line">blur(B, B, Size(<span class="number">9</span>, <span class="number">9</span>));</div><div class="line">imshow(<span class="string">"A2"</span>, A);</div><div class="line">imshow(<span class="string">"B2"</span>, B);</div></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="http://i4.piimg.com/594413/3b8d3749507fafdc.png" alt="Result"><br>看到了吧？原图的那个部分最后也变模糊了。<br>那么如果我们真的想复制一份 <code>Mat</code>，让他们各自有各自的矩阵数据怎么办呢？很简单，<code>Mat</code> 为我们提供了两个成员函数：<code>clone</code> 和 <code>copyTo</code> ：</p>
<ul>
<li><p>clone</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">clone</span> <span class="params">()</span> <span class="keyword">const</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>copyTo</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyTo</span> <span class="params">(OutputArray m)</span> <span class="keyword">const</span></span></div><div class="line"><span class="keyword">void</span> <span class="title">copyTo</span> <span class="params">(OutputArray m, InputArray mask)</span> <span class="keyword">const</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>他们都会将整个 <code>Mat</code> 的信息包括矩阵数据复制一份，所以对复制出来的新对象进行操作，就不会影响到原来的矩阵数据了。<br>值得一提的是 <code>copyTo</code> 的第二个版本，多了一个 <code>mask</code> 参数，这个有什么用呢？当然有用啦，这就是为了方便我们处理那些感兴趣区域（ROI）呀！<a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a626fe5f96d02525e2604d2ad46dd574f" target="_blank" rel="external">官方文档 </a> 给的说明是：</p>
<blockquote>
<p>Operation mask. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. </p>
</blockquote>
<p>按照我目前的理解，就是把你需要的颜色抠出来。比如我们把 <code>OpenCV</code> 图标上面那个红色的圈圈抠出来，我们就用一张灰度图，背景是黑色（0），要抠的地方是白色（255），这样要抠的地方就会原封不动的复制出来了。部分代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Mat src = imread("opencv.jpg", 1);</div><div class="line">Mat out;</div><div class="line"></div><div class="line">Rect r1(Rect(50, 0, 120, 100));</div><div class="line">Mat mask = Mat(src.rows, src.cols, CV_8UC1, Scalar(0));</div><div class="line">mask(r1).setTo(255);</div><div class="line"></div><div class="line">src.copyTo(out, mask);</div><div class="line"></div><div class="line">imshow("src", src);</div><div class="line">imshow("mask", mask);</div><div class="line">imshow("out", out);</div></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="http://i4.piimg.com/594413/4eb9186e6afd1563.png" alt="Result"><br>我们还可以改一下 <code>mask</code> 的参数，看看会有什么效果，比如我们用一个三通道的把背景改为蓝色的 <code>mask</code> 图：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Rect r1(Rect(50, 0, 120, 100));</div><div class="line">Mat mask = Mat(src.rows, src.cols, CV_8UC3, Scalar(255,0,0));</div><div class="line">mask(r1).setTo(255);</div></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="http://i4.piimg.com/594413/209ef984189b3196.png" alt="Result"><br>可能会疑惑：为什么绿色那个圈圈经过这个 <code>mask</code> 后变成黑色了呢？我目前的理解是：从绿色里面（0,255,0）提取蓝色（255,0,0），在蓝色的分量上没有值，所以提取出来的就是黑色了（0,0,0）。</p>
<h3 id="元素值的读写"><a href="#元素值的读写" class="headerlink" title="元素值的读写"></a>元素值的读写</h3><p>前面我们讲的都是整个 <code>Mat</code> 的创建或复制，那如果我们想对 <code>Mat</code> 里的矩阵的元素值进行访问或修改，该怎么做呢？</p>
<h4 id="矩阵的输出"><a href="#矩阵的输出" class="headerlink" title="矩阵的输出"></a>矩阵的输出</h4><p>首先，我们简单的了解一下矩阵的输出，这有助于我们直观的感受矩阵中的数据。 <code>Mat</code> 重载了 <code>operator&lt;&lt;</code> 输出操作符，所以我们可以很方便的就得到格式化输出的结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 声明一个 3x2 的三通道的矩阵</div><div class="line">Mat mat(3, 2, CV_8UC3, Scalar(0, 128, 255));</div><div class="line">std::cout &lt;&lt; "mat = " &lt;&lt; mat &lt;&lt; "\n";</div></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mat = [  0, 128, 255,   0, 128, 255;</div><div class="line">   0, 128, 255,   0, 128, 255;</div><div class="line">   0, 128, 255,   0, 128, 255]</div></pre></td></tr></table></figure></p>
<p><code>OpenCV</code> 还提供了其它很多格式化输出的形式，如 <code>Python</code>、<code>CSV</code>、<code>numpy</code> 等，这里不作为重点，如有兴趣可以看 <a href="http://docs.opencv.org/master/dc/d16/cout_mat_8cpp-example.html#a8" target="_blank" rel="external">这里</a> 的例子，自己尝试。</p>
<h4 id="使用-at-函数"><a href="#使用-at-函数" class="headerlink" title="使用 at() 函数"></a>使用 at() 函数</h4><p><code>Mat</code> 提供了许多的 <code>at</code> 的重载版本对元素值进行读写，就不一一列举了，可以在 <a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#aa5d20fc86d41d59e4d71ae93daee9726" target="_blank" rel="external">这里</a> 查看。需要注意的是，<code>at</code> 需要我们指定一个 <code>_Tp</code> 模板类型，即如文档所说，你需要这样使用：</p>
<ul>
<li>If matrix is of type <code>CV_8U</code> then use <code>Mat.at&lt;uchar&gt;(y,x)</code>.</li>
<li>If matrix is of type <code>CV_8S</code> then use <code>Mat.at&lt;schar&gt;(y,x)</code>.</li>
<li>If matrix is of type <code>CV_16U</code> then use <code>Mat.at&lt;ushort&gt;(y,x)</code>.</li>
<li>If matrix is of type <code>CV_16S</code> then use <code>Mat.at&lt;short&gt;(y,x)</code>.</li>
<li>If matrix is of type <code>CV_32S</code> then use <code>Mat.at&lt;int&gt;(y,x)</code>.</li>
<li>If matrix is of type <code>CV_32F</code> then use <code>Mat.at&lt;float&gt;(y,x)</code>.</li>
<li>If matrix is of type <code>CV_64F</code> then use <code>Mat.at&lt;double&gt;(y,x)</code>.</li>
</ul>
<p>我们可以这样来创建一张黑白过渡的图片：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">255</span>, <span class="number">255</span>, CV_8UC1)</span></span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; img.rows; ++r)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; img.cols; ++c)</div><div class="line">  &#123;</div><div class="line">    img.at&lt;uchar&gt;(r, c) = r % <span class="number">255</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">imshow(<span class="string">"black2white"</span>, img);</div></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="http://i4.piimg.com/594413/ecd13af7689cc545.png" alt="Result"><br> 这是由上至下过渡的，我们还可以弄成从左到右的，只需要把 <code>r % 255</code> 改成 <code>c % 255</code> 就可以啦！<br>当然，<code>at</code> 的模板参数可不是只能用上面所说的那些，我们要保证的是，数据类型能够一一对应。比如我们在弄一个三通道的图像：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">510</span>, <span class="number">510</span>, CV_8UC3)</span></span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.rows; ++i)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.cols; ++j)</div><div class="line">  &#123;</div><div class="line">    Vec3b pixel;</div><div class="line">    pixel[<span class="number">0</span>] = (i + j) % <span class="number">255</span>;</div><div class="line">    pixel[<span class="number">1</span>] = j % <span class="number">255</span>;</div><div class="line">    pixel[<span class="number">2</span>] = i % <span class="number">255</span>;</div><div class="line">    img.at&lt;Vec3b&gt;(i, j) = pixel;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">imshow(<span class="string">"what"</span>, img);</div></pre></td></tr></table></figure></p>
<p>运行效果如下：<br><img src="http://i4.piimg.com/594413/0eb186d6948ecacd.png" alt="Result"><br>你还可以继续更多有趣的尝试！</p>
<h4 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h4><p>如果你熟悉 <code>STL</code>，那么你也一定很喜欢迭代器的读写方式——安全，易写，不易出错。<code>Mat</code> 类也向我们提供了它的迭代器类型 <code>MatIterator_</code>，接下来我们就使用迭代器的方法来生成一张随机色彩的图像吧！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">400</span>, <span class="number">400</span>, CV_8UC3)</span></span>;</div><div class="line">MatIterator_&lt;Vec3b&gt; iter;</div><div class="line"><span class="keyword">for</span> (iter = img.begin&lt;Vec3b&gt;(); iter != img.end&lt;Vec3b&gt;(); ++iter)</div><div class="line">&#123;</div><div class="line">  Vec3b pixel;</div><div class="line">  pixel[<span class="number">0</span>] = rand() % <span class="number">255</span>;</div><div class="line">  pixel[<span class="number">1</span>] = rand() % <span class="number">255</span>;</div><div class="line">  pixel[<span class="number">2</span>] = rand() % <span class="number">255</span>;</div><div class="line">  *iter = pixel;</div><div class="line">&#125;</div><div class="line">imshow(<span class="string">"what"</span>, img);</div></pre></td></tr></table></figure></p>
<p>运行效果如下:<br><img src="http://i4.piimg.com/594413/ab05f3d9e9f4bcc0.png" alt="Result"><br>有点像电视雪花啊哈哈，每次运行的结果肯定都一样的，不过都是乱七八糟的了。</p>
<h4 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h4><p><code>Mat</code> 同样提供了一个 <code>ptr</code> 函数及其的许多重载版本，可以在 <a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a13acd320291229615ef15f96ff1ff738" target="_blank" rel="external">这里</a> 查看。使用指针确实是更容易出错，因为 C-style 指针是不带范围检查的。不过我觉得这点小事也怕干脆就别学了。听说用指针的效率会更高，当然我现在还没有进行充足的测试，有兴趣的朋友可以自己测试一下。我就举跟使用 <code>at</code> 一样的例子吧：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">255</span>, <span class="number">255</span>, CV_8UC1)</span></span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; img.rows; ++r)</div><div class="line">&#123;</div><div class="line">  uchar* p = img.ptr&lt;uchar&gt;(r);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; img.cols; ++c)</div><div class="line">  &#123;</div><div class="line">    p[c] = r % <span class="number">255</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">imshow(<span class="string">"black2white"</span>, img);</div></pre></td></tr></table></figure></p>
<p>上述代码同样是实现了一个黑白过渡的图像生成。</p>
<h3 id="Mat-类"><a href="#Mat-类" class="headerlink" title="Mat_ 类"></a>Mat_ 类</h3><p>有没有觉得上面很多 <code>at&lt;uchar&gt;</code>， <code>ptr&lt;uchar&gt;</code> 的写法很烦？而且更重要的是，这是不能做编译器检查的，也就算说，你写成以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">255</span>, <span class="number">255</span>, CV_8UC1)</span></span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; img.rows; ++r)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; img.cols; ++c)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 这里应为 uchar</span></div><div class="line">    img.at&lt;<span class="keyword">double</span>&gt;(r, c) = r % <span class="number">255</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译期是没法检查这个类型错误的，直到运行期才会炸掉。<code>Mat_</code> 类就是来解决这个问题的，<code>Mat_</code> 类就是对 <code>Mat</code> 的一个封装，加上了一个模板参数用于指定类型，这样就可以免去很多麻烦和造成错误的可能。例如以下一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">255</span>, <span class="number">255</span>, CV_8UC1)</span></span>;</div><div class="line">Mat_&lt;uchar&gt; img2(img);  <span class="comment">// Mat_ 对象</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; img2.rows; ++r)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">auto</span> p = img2.ptr();  <span class="comment">// 不需要指定类型了</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; img2.cols; ++c)</div><div class="line">  &#123;</div><div class="line">    img2(r, c) = r % <span class="number">255</span>;  <span class="comment">// 可以使用 Matlab 风格</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">imshow(<span class="string">"black2white"</span>, img2);</div></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Mat</code> 是整个 <code>OpenCV</code> 中非常重要的一个数据结构，它还有许多操作，以上只提到了冰山一角，可以从 <a href="http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html" target="_blank" rel="external">这里</a> 获取更多的信息。不断的练习与思考，就是进步的唯一途径。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;OpenCV&lt;/code&gt; 的很多跟图像有关的东西里，都离不开一样东西 —— &lt;code&gt;Mat&lt;/code&gt; 类。读一张图片，返回的是一个 &lt;code&gt;Mat&lt;/code&gt;，显示一张图片，用的也是 &lt;code&gt;Mat&lt;/code&gt;。我们都知道这是一个矩阵类
    
    </summary>
    
      <category term="opencv" scheme="http://www.alinshans.com/categories/opencv/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
      <category term="opencv" scheme="http://www.alinshans.com/tags/opencv/"/>
    
      <category term="visual studio" scheme="http://www.alinshans.com/tags/visual-studio/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 笔记（一）：图像与视频的输入输出</title>
    <link href="http://www.alinshans.com/2017/07/06/p1707062/"/>
    <id>http://www.alinshans.com/2017/07/06/p1707062/</id>
    <published>2017-07-06T09:19:48.000Z</published>
    <updated>2017-07-10T04:19:59.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><p>在 <a href="http://www.alinshans.com/2017/07/06/p1707061/">上一篇</a> 中，我们运行了一个程序，显示一张图片：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 把下面的 1.jpg 改成自己的图片的名称</span></div><div class="line">    Mat img = imread(<span class="string">"1.jpg"</span>);</div><div class="line">    imshow(<span class="string">"图片"</span>, img);</div><div class="line">    waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实不要看短短几行就实现了这个功能，但背后的工作其实是非常复杂繁多的。我们一点点来解释。</p>
<p>首先第一行，是一个 <code>#include</code> 声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>其实 <code>OpenCV</code> 是有很多模块的，各个模块都有其对应的头文件，而 <code>opencv.hpp</code> 这个头文件就包含了各个模块的头文件，所以这是一个最简洁的写法。</p>
<p>然后可能会有人指出，我在 <a href="http://www.alinshans.com/2017/05/22/p1705221/">之前的一篇博客</a> 中，不是说不要使用 using namespace 吗？为什么这里又出现了呢？这是因为我是为了写一个 demo，我就是最终的用户了啊！不违背我的原则 =v=</p>
<p>接下来，声明并初始化了一个 <code>Mat</code> 对象，这个 <code>Mat</code> 对象是 <code>OpenCV</code> 中的 n 维密集数值阵列，可用于储存矩阵、灰度或彩色图像等，我们暂时不深入去了解它，这个部分会放到后面。<br>初始化调用了一个函数 <a href="http://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56" target="_blank" rel="external">imread</a>，我们来看看这个函数的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Mat <span class="title">imread</span><span class="params">(<span class="keyword">const</span> String &amp;filename, <span class="keyword">int</span> flags = IMREAD_COLOR)</span></span></div></pre></td></tr></table></figure></p>
<p>这个函数从一个文件中加载图片，第一个参数是文件名，第二个参数是打开的模式，它有一个缺省值 <code>IMREAD_COLOR</code>，代表将图像转换为三通道的彩色图像，一般使用默认值即可，想了解更多模式可以看 <a href="http://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga61d9b0126a3e57d9277ac48327799c80" target="_blank" rel="external">这里</a>。</p>
<p>然后是一个 <a href="http://docs.opencv.org/master/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563" target="_blank" rel="external">imshow</a> 函数，这个函数会创建一个窗口并显示图像，我们看看它的函数声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">imshow</span><span class="params">(<span class="keyword">const</span> String&amp; winname, InputArray mat)</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一个参数代表窗口的标题，第二个参数代表储存图像的对象。</p>
<p>最后是一个 <a href="http://docs.opencv.org/master/d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7" target="_blank" rel="external">waitKey</a> 函数，它的函数声明是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitKey</span><span class="params">(<span class="keyword">int</span> delay = <span class="number">0</span>)</span></span></div></pre></td></tr></table></figure></p>
<p>它用于等待用户输入一个键并返回，<code>delay</code> 代表等待的毫秒数，缺省值为 0，当 <code>delay</code> 为非正数（&lt;=0）时，代表的就是无限等待直到用户输入一个键。</p>
<p>以上就是这部分代码的介绍，其中，<code>imread</code> 属于图像读写部分，可以在 <a href="http://docs.opencv.org/master/d4/da8/group__imgcodecs.html" target="_blank" rel="external">这里</a> 查看更多相关函数的信息；<code>imshow</code> 和 <code>waitKey</code> 属于 GUI 部分，可以在 <a href="http://docs.opencv.org/master/d7/dfc/group__highgui.html" target="_blank" rel="external">这里</a> 查看更多相关函数的信息。</p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>我们有了一些直观的认识之后，在来一些感观的认识。官网给出了非常多的关于图像处理的 <a href="http://docs.opencv.org/master/d7/da8/tutorial_table_of_content_imgproc.html" target="_blank" rel="external">教程</a>，我们可以都尝试一下，并且它每个例子下面都会有 <code>Explanation</code>，可谓是非常良心了。如果看英文不顺利的童鞋，可以看对应的中文网的教程，会有一些出入，但大体上差不多。</p>
<h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p>我们也可以用一个简短的程序，就能实现一个视频的读取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 将 1.mp4 替换成自己的视频文件</span></div><div class="line">  <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">"1.mp4"</span>)</span></span>;</div><div class="line">    <span class="comment">// 循环显示每一帧</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">      Mat frame;</div><div class="line">      <span class="comment">// 读取当前帧到 frame</span></div><div class="line">      capture &gt;&gt; frame;  </div><div class="line">      <span class="keyword">if</span> (frame.empty())</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      imshow(<span class="string">"视频"</span>, frame);</div><div class="line">      <span class="comment">// 每一帧之间的间隔(ms)</span></div><div class="line">      waitKey(<span class="number">20</span>);</div><div class="line">    &#125;</div><div class="line">    waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后它就能像一个播放器一样“播放”整个视频啦！<br>试试看把<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">"1.mp4"</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这一句改成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>会发生什么吧 ^_^<br>更多视频处理相关内容可以看 <a href="http://docs.opencv.org/master/dd/de7/group__videoio.html" target="_blank" rel="external">这里</a> 哦！</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>OpenCV</code> 毕竟是一个库，我们学习它，没必要像教科书式的，按顺序去学习它的各个模块、功能。我们想做什么，就直接去做，要用到什么，我们就查文档、查资料。在实践中学习，也是快速成长的一种方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一个程序&quot;&gt;&lt;a href=&quot;#第一个程序&quot; class=&quot;headerlink&quot; title=&quot;第一个程序&quot;&gt;&lt;/a&gt;第一个程序&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;http://www.alinshans.com/2017/07/06/p1707061/&quot;&gt;
    
    </summary>
    
      <category term="opencv" scheme="http://www.alinshans.com/categories/opencv/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
      <category term="opencv" scheme="http://www.alinshans.com/tags/opencv/"/>
    
      <category term="visual studio" scheme="http://www.alinshans.com/tags/visual-studio/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 笔记（零）：启程</title>
    <link href="http://www.alinshans.com/2017/07/06/p1707061/"/>
    <id>http://www.alinshans.com/2017/07/06/p1707061/</id>
    <published>2017-07-05T16:15:07.000Z</published>
    <updated>2017-07-09T15:18:52.802Z</updated>
    
    <content type="html"><![CDATA[<p><code>OpenCV</code> 是一个计算机视觉库，它提供了很多图像处理、机器学习等通用的算法，而且提供了 <code>C++</code>, <code>Python</code>, <code>Ruby</code> 等语言的接口。我们可以在 <a href="http://opencv.org/" target="_blank" rel="external">官网</a> 上查看你想知道的信息。现在最新版本为 3.2.0，用过之后才感觉 <code>OpenCV</code> 的强大啊。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>很多人想用 <code>OpenCV</code>，但或许就栽到了环境搭建这第一步了，但我觉得现在这个版本搭建起来还是挺方便的，在官网上有各种系统和编译器的搭建指导（<a href="http://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html" target="_blank" rel="external">点这里</a>）。我使用的是 Windows + VS2017，所以在接下来的系列文章中，没有特殊说明，我使用的都是 <code>C++</code> 接口。环境搭建主要参考了 <a href="http://docs.opencv.org/master/d3/d52/tutorial_windows_install.html" target="_blank" rel="external">这篇教程</a> 和 <a href="http://docs.opencv.org/master/d6/d8a/tutorial_windows_visual_studio_Opencv.html" target="_blank" rel="external">这篇教程</a>。</p>
<p>首先我们可以在 <a href="http://opencv.org/releases.html" target="_blank" rel="external">RELEASES</a> 页面下载最新的版本，我下载的是 <a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.2.0/opencv-3.2.0-vc14.exe/download" target="_blank" rel="external">Win pack</a>。下载完成后，我们打开它解压到一个目录:<br><img src="http://i2.kiimg.com/594413/8b09c6dc35e0f733.png" alt="opencv_extract"></p>
<p>比如我解压到 <code>H:\</code> ,那么在 <code>H:\</code> 目录下就会有个 <code>opencv</code> 文件夹，我们打开它可以看到里面有一个 <code>build</code> 文件夹，里面是已经构建好的各种东西。<code>build</code> 文件夹里面的 <code>include\opencv2</code> 就是 <code>OpenCV</code> 的各种头文件。还有个 <code>x64\vc14</code>，这是给 <code>vs2015</code>（或以上）在 <code>x64</code> 平台上使用的各种东西（<code>.dll</code>,<code>.lib</code>文件等），我们会注意到，有一些文件非常相似，就是结尾有没有 <code>d</code> 的差别，如 <code>opencv_world320.lib</code> 和 <code>opencv_world320d.lib</code>，要注意，以 <code>d</code> 结尾的，是给 <code>Debug</code> 模式使用的，没有 <code>d</code> 结尾的则是给 <code>Release</code> 模式使用的，要注意这个区别，下面会用到。</p>
<p>接下来就是配置环境变量，可以参考 <a href="http://docs.opencv.org/master/d3/d52/tutorial_windows_install.html#tutorial_windows_install_path" target="_blank" rel="external">这个部分</a> 和 <a href="http://docs.opencv.org/master/d6/d8a/tutorial_windows_visual_studio_Opencv.html" target="_blank" rel="external">这个部分</a>，当然如果你不想看，我可以简单的告诉你要做的事情：</p>
<ol>
<li><p>先添加一个环境变量指定到 <code>OpenCV</code> 的目录<br>这里不一定要按上面教程上的来，例如我是添加了一个 <code>OpencvDir</code> 变量，值为 <code>H:\opencv\build</code>，为什么要加这个环境变量呢？其实也可以用绝对路径，添加这个环境变量的目的是当你 <code>opencv</code> 这个目录路径变化时，不用全部与之相关的东西都要改，只需要改这个环境变量的值就可以了。<br><img src="http://i2.kiimg.com/594413/1412277f4c795399.png" alt="environment variable"></p>
</li>
<li><p>把 <code>opencv\build\bin</code> 路径加入到系统的 <code>Path</code> 中<br>这是因为要使用到里面的动态库（<code>.dll</code>文件）。<strong>如果运行提示缺少 <code>.dll</code>，就要去看看这个环境变量有没有设置正确了。</strong></p>
</li>
<li><p>配置 <code>vs</code> 项目属性<br>打开 <code>vs</code>，新建一个项目，我们先把解决方案配置为 <code>Debug|x64</code>。要使用 <code>opencv</code>，简单来说就是要解决两件事：</p>
</li>
</ol>
<ul>
<li>告诉编译器在哪里找到 <code>opencv</code> 库</li>
<li>告诉链接器在哪里找到 <code>opencv</code> 库里面各种函数与数据结构的原型<br>具体要做的有三件事：<br>打开项目属性，在 <code>C/C++</code> -&gt; <code>常规(General)</code> 选项卡中，编辑 <code>附加包含目录(Additional Include Directories)</code>，加入 <code>opencv\build\include</code> 这个目录，对应我自己的环境变量，我就加入 <code>$(OpencvDir)\include</code> 。<br><img src="http://i1.buimg.com/594413/9604e10c289bc72f.png" alt="Additional Include Directories"><br>打开 <code>链接器(Linker)</code> -&gt; <code>常规(General)</code> 选项卡，编辑 <code>附加库目录(Additional Library Directories）</code>，加入 <code>opencv\build\x64\vc14\lib</code> 这个目录，对应我自己的环境变量，我加入的是 <code>$(OpencvDir)\x64\vc14\lib</code> 。<br><img src="http://i1.buimg.com/594413/135dcd48a87d3ed6.png" alt="Additional Library Directories"><br>打开 <code>链接器(Linker)</code> -&gt; <code>输入(Input)</code> 选项卡，编辑 <code>附加依赖项(Additional Dependencies)</code>，然后把 <code>x64\vc14\lib</code> 里面的 <code>opencv_world320d.lib</code> 这个文件加入进去，因为我们配置的是 <code>Debug</code> 模式，就加入对应的这个 <code>.lib</code> 文件。<br><img src="http://i1.buimg.com/594413/6cff22e25822ec5a.png" alt="Additional Dependencies"></li>
</ul>
<p>至此，<code>OpenCV</code> 在 <code>vs</code> 上的环境算是搭建好啦！有一些需要注意的点：<br><strong>※ 哪个模式就添加哪个模式对应的 <code>.lib</code> 文件，Debug 模式就要添加 <code>opencv_world320d.lib</code> 的。改了模式就要把上述的重新配置一遍。</strong><br><strong>※ 如果在打开 <code>vs</code> 的时候去修改了环境变量，<code>vs</code> 不会自动更新，需要重启 <code>vs</code>。</strong></p>
<h3 id="使用-OpenCV"><a href="#使用-OpenCV" class="headerlink" title="使用 OpenCV"></a>使用 <code>OpenCV</code></h3><p>我们马上来运行一个简单的例子吧：显示图片。<br>首先，找一张图片放到跟 <code>main()</code> 函数同级的目录下，然后输入以下这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 把下面的 1.jpg 改成自己的图片的名称</span></div><div class="line">    Mat img = imread(<span class="string">"1.jpg"</span>);</div><div class="line">    imshow(<span class="string">"图片"</span>, img);</div><div class="line">    waitKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按下 Ctrl + F5 运行，成功后你就能看到这样的画面啦！<br><img src="http://i4.piimg.com/594413/7cdc138c2e1d8c48.png" alt="Demo"></p>
<h3 id="学习-OpenCV"><a href="#学习-OpenCV" class="headerlink" title="学习 OpenCV"></a>学习 <code>OpenCV</code></h3><p>刚搭建好环境，我就把 <a href="http://docs.opencv.org/master/d9/df8/tutorial_root.html" target="_blank" rel="external">Tutorials</a> 里的 <a href="http://docs.opencv.org/master/d7/da8/tutorial_table_of_content_imgproc.html" target="_blank" rel="external">Image Processing</a> 部分基本都跑了遍，包括平滑处理、形态变换、二值化、加边框等等，还是挺好玩，也挺好奇的。</p>
<p>耐心探索，<code>OpenCV</code> 还有非常多强大的功能，我主要会通过以下三个网站学习：</p>
<ul>
<li>官方网站：<a href="http://opencv.org/" target="_blank" rel="external">http://opencv.org/</a></li>
<li><code>OpenCV</code> 中文网：<a href="http://www.opencv.org.cn/" target="_blank" rel="external">http://www.opencv.org.cn/</a></li>
<li><code>CSDN</code> <code>OpenCV</code> 知识库：<a href="http://lib.csdn.net/base/opencv" target="_blank" rel="external">http://lib.csdn.net/base/opencv</a></li>
</ul>
<p>可以开始尽情的玩耍啦 o(<em>￣▽￣</em>)ブ</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;OpenCV&lt;/code&gt; 是一个计算机视觉库，它提供了很多图像处理、机器学习等通用的算法，而且提供了 &lt;code&gt;C++&lt;/code&gt;, &lt;code&gt;Python&lt;/code&gt;, &lt;code&gt;Ruby&lt;/code&gt; 等语言的接口。我们可以在 &lt;a href=&quot;
    
    </summary>
    
      <category term="opencv" scheme="http://www.alinshans.com/categories/opencv/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
      <category term="opencv" scheme="http://www.alinshans.com/tags/opencv/"/>
    
      <category term="visual studio" scheme="http://www.alinshans.com/tags/visual-studio/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（四）</title>
    <link href="http://www.alinshans.com/2017/06/10/p1706101/"/>
    <id>http://www.alinshans.com/2017/06/10/p1706101/</id>
    <published>2017-06-10T13:57:56.000Z</published>
    <updated>2017-07-28T17:03:34.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h3><p>昨天花了一些时间给我的 <a href="https://github.com/Alinshans/MyTinySTL" target="_blank" rel="external">MyTinySTL</a> 重新弄了一套构建方案，主要是写了一个 <code>CMakeLists.txt</code>（原来是写了一个简单的 <code>Makefile</code>）。现在呢，在 linux/osx 下，就通过 <code>cmake</code> 来构建生成对应的 <code>Makefile</code>，然后再 <code>make</code>；在 Windows 下，就直接使用 <code>vs</code> 的 <code>.sln</code> 配置文件。具体可以看项目说明。</p>
<h3 id="问题浮现"><a href="#问题浮现" class="headerlink" title="问题浮现"></a>问题浮现</h3><p>然后修改完持续集成的脚本配置之后，却出现了一个奇怪的问题：<strong>在 linux 下的构建全部失败了！</strong><br><img src="http://i2.muimg.com/594413/04c6fcad6f5a5b6bs.png" alt="build message"><br>打开查看里面的信息，基本都是这样的错误提示：<br>gcc提示是这样的：<br><img src="http://i2.muimg.com/594413/ce1871e70d13334fs.png" alt="build message"><br>clang提示是这样的：<br><img src="http://i2.muimg.com/594413/e20d3654bb3bee12s.png" alt="build message"><br>都是在 <code>&lt;cstring&gt;</code> 这个文件出错了，可这是标准库文件，怎么会出错呢？而且错误信息也很奇怪。我又去找代码查找有没有什么可能出错的地方，很久也没找到。然后跟别人请教了一下，某大神直击要害地问我：<strong>“你是不是有一个 string.h 文件？”</strong></p>
<h3 id="找到缘由"><a href="#找到缘由" class="headerlink" title="找到缘由"></a>找到缘由</h3><p><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" target="_blank" rel="external"><code>c11</code></a> 中有这样一段话：<br><img src="http://i2.muimg.com/594413/2d06f684a59f5cdes.png" alt="c11 standard headers"><br>注意框出来的地方：</p>
<blockquote>
<p>If a ﬁle with the same name as one of the above &lt; and &gt; delimited sequences, not provided as part of the implementation, is placed in any of the standard places that are searched for included source ﬁles, the behavior is undeﬁned.</p>
</blockquote>
<p>也就是说，如果有一个文件跟上述标准库文件<strong>重名</strong>，然后被包含在源文件中时，是<strong>未定义行为</strong>。<br>恰好，因为我写的是 tinystl，所以我写了一个 <code>string.h</code>，没错，就是跟我框出来那个 <code>&lt;string.h&gt;</code> 重名了！！<br>解决办法就是 —— <strong>换个名字</strong>~ 是的，然后我就把 <code>string.h</code> 改成了 <code>astring.h</code>，问题就解决了！( ╯□╰ )<br>一波三折，谨以记之，提醒自己做过的傻x事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事情起因&quot;&gt;&lt;a href=&quot;#事情起因&quot; class=&quot;headerlink&quot; title=&quot;事情起因&quot;&gt;&lt;/a&gt;事情起因&lt;/h3&gt;&lt;p&gt;昨天花了一些时间给我的 &lt;a href=&quot;https://github.com/Alinshans/MyTinySTL&quot; t
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://www.alinshans.com/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编：组织程序</title>
    <link href="http://www.alinshans.com/2017/05/31/p1705312/"/>
    <id>http://www.alinshans.com/2017/05/31/p1705312/</id>
    <published>2017-05-31T08:32:29.000Z</published>
    <updated>2017-05-31T12:26:53.625Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们介绍了8086汇编中一些常用的、基本的、重要的概念，现在我们就要把这些东西组装起来。</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var_name <span class="built_in">db</span>/<span class="built_in">dw</span>/<span class="built_in">dd</span> expression</div></pre></td></tr></table></figure>
<p>其中的 <code>var_name</code> 就是一个变量，<code>db</code>/<code>dw</code>/<code>dd</code>是伪指令助记符，用于指定字节/字/双字，表达式可以为一个常量，一个字符串等。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data <span class="meta">segment</span></div><div class="line">    num <span class="built_in">dw</span> <span class="number">0</span></div><div class="line">    msg <span class="built_in">db</span> <span class="string">'please input a num'</span></div><div class="line">    len <span class="built_in">db</span> $-msg1</div><div class="line">data ends</div></pre></td></tr></table></figure></p>
<p>操作数<code>&#39;?&#39;</code>用于保留储存空间，但不存入数据。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">adc</span> <span class="built_in">db</span> <span class="number">0</span>, <span class="number">1</span>, ?, ?, ?</div><div class="line">len <span class="built_in">db</span> ?</div></pre></td></tr></table></figure></p>
<p>操作数字段还可以利用复制操作符 <code>dup</code> 来复制重复元素。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abc <span class="built_in">db</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span> dup (?)</div><div class="line">ssr <span class="built_in">db</span> <span class="number">5</span> dup (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<h3 id="程序的开始与结束"><a href="#程序的开始与结束" class="headerlink" title="程序的开始与结束"></a>程序的开始与结束</h3><h4 id="1-end-伪指令"><a href="#1-end-伪指令" class="headerlink" title="1. end 伪指令"></a>1. <code>end</code> 伪指令</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">end label</span></div></pre></td></tr></table></figure>
<p><code>end</code> 伪指令标识着整个程序的结束，<code>end</code> 后面的操作数指定程序执行的起始地址。所以，一般主程序模板必须 <code>end</code> 后面指定操作数，然后在操作数放到代码段的开头，如：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code, <span class="built_in">ds</span>:data</div><div class="line"></div><div class="line">data segments</div><div class="line">    <span class="comment">; ... </span></div><div class="line">data ends</div><div class="line"></div><div class="line">code segments</div><div class="line"><span class="symbol">start:</span>     <span class="comment">; 程序执行的起始地址</span></div><div class="line">    <span class="comment">; ...</span></div><div class="line">code ends </div><div class="line">end start  <span class="comment">; 表明 start 为程序执行的起始地址</span></div></pre></td></tr></table></figure></p>
<h4 id="2-assume-伪指令"><a href="#2-assume-伪指令" class="headerlink" title="2. assume 伪指令"></a>2. <code>assume</code> 伪指令</h4><p>8086存储器是分段的，分了段之后，就必须指明段和段寄存器之间的关系，这由假设语句 <code>assume</code> 实现。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">assume</span> segment_reg : segment_name [,...]</div></pre></td></tr></table></figure></p>
<p>其中，<code>segment_reg</code> 必须是 <code>cs</code>, <code>ds</code>, <code>ss</code>, <code>es</code> 中的一个，<code>segment_name</code> 则是定义的段名。</p>
<p><strong>注意：<code>assume</code> 伪指令只是指定了某个段分配给某个段寄存器，但它并没有将段地址装入段寄存器，所以在代码段中，还要将段地址装入段寄存器。</strong></p>
<h4 id="3-定义段"><a href="#3-定义段" class="headerlink" title="3. 定义段"></a>3. 定义段</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">segment_name <span class="meta">segment</span> [align_type] [combine_type] [use_type] [<span class="string">'class'</span>]</div><div class="line">...</div><div class="line">segment_name ends</div></pre></td></tr></table></figure>
<p>其中，<code>[]</code>代表是可选的，可以缺省的，但各项顺序不能错，<strong>一般不需要我们指定</strong>。</p>
<h4 id="4-定义过程"><a href="#4-定义过程" class="headerlink" title="4. 定义过程"></a>4. 定义过程</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process_name proc [<span class="built_in">near</span>/<span class="built_in">far</span>]</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">process_name endp</div></pre></td></tr></table></figure>
<p>在 <code>proc</code> 后面可以指定 <code>near</code>（默认）—— 在段内被调用，<code>far</code>—— 可以被段外调用。</p>
<p>在 <code>masm</code> 中，过程含义跟子程序一样，可以通过 <code>call</code> 来调用，过程返回自动调用 <code>ret</code>。</p>
<h3 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h3><p>子程序跟过程段类似，通过 <code>call</code> 调用，<code>ret</code> 来返回，重点要注意<strong>现场保护</strong>，<strong>参数传递</strong>等问题。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">name:</span></div><div class="line">    <span class="comment">; 要用到的寄存器压栈</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></div><div class="line">    <span class="comment">; ...</span></div><div class="line"></div><div class="line">    <span class="comment">; 子程序过程...</span></div><div class="line"></div><div class="line">    <span class="comment">; 恢复寄存器</span></div><div class="line">    <span class="keyword">pop</span> <span class="built_in">bx</span></div><div class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></div><div class="line">    <span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<h3 id="简化段"><a href="#简化段" class="headerlink" title="简化段"></a>简化段</h3><p>简化段首先要定义程序的存储模型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">存储模型</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">适用系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tiny（微型）</td>
<td style="text-align:center">所有数据和代码都放在一个段内，其访问都为NEAR型，整个程序≤64K，并会产生.COM文件</td>
<td style="text-align:center">MS-DOS</td>
</tr>
<tr>
<td style="text-align:center">small（小型）</td>
<td style="text-align:center">所有代码在一个64KB的段内，所有数据在另一个64KB的段内（包括数据段,堆栈段和附加段）</td>
<td style="text-align:center">MS-DOS<br>Windows</td>
</tr>
<tr>
<td style="text-align:center">medium（中型）</td>
<td style="text-align:center">所有代码＞64K时可放在多个代码段中，转移或调用可为FAR型。所有数据限在一个段内，DS可保持不变</td>
<td style="text-align:center">MS-DOS<br>Windows</td>
</tr>
<tr>
<td style="text-align:center">compact（紧凑型）</td>
<td style="text-align:center">所有代码限在一个段内，转移或调用可为NEAR型。数据＞64K时，可放在多个段中</td>
<td style="text-align:center">MS-DOS<br>Windows</td>
</tr>
<tr>
<td style="text-align:center">large（大型）</td>
<td style="text-align:center">允许代码段和数据段都可超过64K，被放置在有多个段内，所以数据和代码都是远访问</td>
<td style="text-align:center">MS-DOS<br>Windows</td>
</tr>
<tr>
<td style="text-align:center">huge（巨型）</td>
<td style="text-align:center">单个数据项可以超过64K，其它同<code>large</code>模型</td>
<td style="text-align:center">MS-DOS<br>Windows</td>
</tr>
</tbody>
</table>
<p>说明：<code>small</code> 模型是一般应用程序最常用的一种模型，因为只有一个代码段和一个数据段，所以数据和代码都是近访问的。<strong>所以一般将 <code>.model</code> 指定为 <code>small</code> 就可以了。</strong></p>
<p>简化段伪指令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">伪指令</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.code [段名]</td>
<td style="text-align:center">创建一个代码段</td>
<td style="text-align:center">隐含段名为 <code>@code</code></td>
</tr>
<tr>
<td style="text-align:center">.data</td>
<td style="text-align:center">创建一个数据段</td>
<td style="text-align:center">隐含段名为 <code>@data</code></td>
</tr>
<tr>
<td style="text-align:center">.stack [大小]</td>
<td style="text-align:center">创建一个堆栈段并指定大小</td>
<td style="text-align:center">隐含段名为 <code>@stack</code>，并形成<code>ss</code>和<code>sp</code>的初值</td>
</tr>
</tbody>
</table>
<p>例：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">.model</span> small</div><div class="line"><span class="meta">.stack</span> <span class="number">100h</span></div><div class="line"><span class="meta">.data</span>  <span class="comment">; 定义数据段</span></div><div class="line">    <span class="comment">;...</span></div><div class="line"><span class="meta"></span></div><div class="line">.code  <span class="comment">; 定义代码段</span></div><div class="line"><span class="symbol">main:</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, @data <span class="comment">; 数据段地址</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></div><div class="line">    <span class="comment">; ...</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></div><div class="line">    <span class="keyword">int</span> <span class="number">21h</span></div><div class="line">end main</div></pre></td></tr></table></figure></p>
<h3 id="其他伪操作"><a href="#其他伪操作" class="headerlink" title="其他伪操作"></a>其他伪操作</h3><h4 id="1-基数控制"><a href="#1-基数控制" class="headerlink" title="1. 基数控制"></a>1. 基数控制</h4><p>汇编程序默认的数为十进制数，还可以由以下方式指定基数：</p>
<ol>
<li>二进制： 01001000b</li>
<li>八进制： 123q 或 123o</li>
<li>十进制： 1234d</li>
<li>十六进制： 1234h / 0ffffh （第一个为字母时前面加0）</li>
</ol>
<h4 id="2-39-39-地址计数器"><a href="#2-39-39-地址计数器" class="headerlink" title="2. &#39;$&#39; 地址计数器"></a>2. <code>&#39;$&#39;</code> 地址计数器</h4><p><code>&#39;$&#39;</code>保存了当前汇编指令的偏移地址。</p>
<p>常用用途：</p>
<ul>
<li><p>计算字符串长度</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data <span class="meta">segment</span></div><div class="line">    str1 <span class="built_in">db</span> <span class="string">'hello'</span></div><div class="line">    len1 <span class="built_in">db</span> $-str1  <span class="comment">; 5</span></div><div class="line">    str2 <span class="built_in">db</span> <span class="string">'world hahaha'</span></div><div class="line">    len2 <span class="built_in">db</span> $-str2  <span class="comment">; 12</span></div><div class="line">data ends</div></pre></td></tr></table></figure>
</li>
<li><p>跳转</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">jne</span> $+<span class="number">6</span>  <span class="comment">; 跳转到 jne 指令所在地址 + 6</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们介绍了8086汇编中一些常用的、基本的、重要的概念，现在我们就要把这些东西组装起来。&lt;/p&gt;
&lt;h3 id=&quot;定义变量&quot;&gt;&lt;a href=&quot;#定义变量&quot; class=&quot;headerlink&quot; title=&quot;定义变量&quot;&gt;&lt;/a&gt;定义变量&lt;/h3&gt;&lt;figure cla
    
    </summary>
    
      <category term="汇编" scheme="http://www.alinshans.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://www.alinshans.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编：指令系统（下）</title>
    <link href="http://www.alinshans.com/2017/05/31/p1705311/"/>
    <id>http://www.alinshans.com/2017/05/31/p1705311/</id>
    <published>2017-05-31T02:15:47.000Z</published>
    <updated>2017-05-31T07:10:14.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="1-jmp（无条件转移）"><a href="#1-jmp（无条件转移）" class="headerlink" title="1. jmp（无条件转移）"></a>1. jmp（无条件转移）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">jmp label</span>       <span class="comment">; 跳到 label 的地址</span></div><div class="line"><span class="keyword">jmp</span> reg16/mem16 <span class="comment">; 段内转移，ip = reg16/[mem16]</span></div><div class="line"><span class="keyword">jmp</span> mem32       <span class="comment">; 段间转移，cs = mem32高字，ip = mem32低字</span></div></pre></td></tr></table></figure>
<p>可以加上 <code>short</code>, <code>near</code>, <code>far</code> 等标识符，分别表明是短转移（<code>ip</code>修改范围 -128 ~ 127）、近转移（<code>ip</code>修改范围 -32768 ~ 32767）、远转移（<code>cs</code>:<code>ip</code>都修改）。</p>
<h3 id="2-jcc（条件转移）"><a href="#2-jcc（条件转移）" class="headerlink" title="2. jcc（条件转移）"></a>2. jcc（条件转移）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">jcc label</span>  <span class="comment">; 若成立，ip 修改为 label 的偏移地址（-128~127），否则忽略该指令</span></div></pre></td></tr></table></figure>
<h4 id="简单测试条件的jcc指令"><a href="#简单测试条件的jcc指令" class="headerlink" title="简单测试条件的jcc指令"></a>简单测试条件的<code>jcc</code>指令</h4><table>
<thead>
<tr>
<th style="text-align:center">jcc 指令</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">转移条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jz/je</td>
<td style="text-align:center">为零（相等）时转移</td>
<td style="text-align:center"><code>zf</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">jnz/jne</td>
<td style="text-align:center">非零（不等）时转移</td>
<td style="text-align:center"><code>zf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jc/jb</td>
<td style="text-align:center">有进位时转移</td>
<td style="text-align:center"><code>cf</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">jnc/jnb</td>
<td style="text-align:center">无进位时转移</td>
<td style="text-align:center"><code>cf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">js</td>
<td style="text-align:center">为负时转移</td>
<td style="text-align:center"><code>sf</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">jns</td>
<td style="text-align:center">为正时转移</td>
<td style="text-align:center"><code>sf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jo</td>
<td style="text-align:center">溢出时转移</td>
<td style="text-align:center"><code>of</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">jno</td>
<td style="text-align:center">不溢出时转移</td>
<td style="text-align:center"><code>of</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jp/jpe</td>
<td style="text-align:center">奇偶位为<code>1</code>时转移</td>
<td style="text-align:center"><code>pf</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">jnp/jpo</td>
<td style="text-align:center">奇偶位为<code>0</code>时转移</td>
<td style="text-align:center"><code>pf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jcxz</td>
<td style="text-align:center"><code>cx</code>为<code>0</code>时转移</td>
<td style="text-align:center"><code>cf</code> = 0</td>
</tr>
</tbody>
</table>
<h4 id="带符号数比较的jcc指令"><a href="#带符号数比较的jcc指令" class="headerlink" title="带符号数比较的jcc指令"></a>带符号数比较的<code>jcc</code>指令</h4><table>
<thead>
<tr>
<th style="text-align:center">jcc 指令</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">转移条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jg/jnle</td>
<td style="text-align:center">大于（不小于等于）时转移</td>
<td style="text-align:center"><code>sf</code> = <code>of</code> 且 <code>zf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jge/jnl</td>
<td style="text-align:center">大于等于（不小于）时转移</td>
<td style="text-align:center"><code>sf</code> = <code>pf</code></td>
</tr>
<tr>
<td style="text-align:center">jl/jnge</td>
<td style="text-align:center">小于（不大于等于）时转移</td>
<td style="text-align:center"><code>sf</code> ≠ <code>of</code></td>
</tr>
<tr>
<td style="text-align:center">jle/jng</td>
<td style="text-align:center">小于等于（不大于）时转移</td>
<td style="text-align:center"><code>sf</code> ≠ <code>of</code> 且 <code>zf</code> ≠ 0</td>
</tr>
</tbody>
</table>
<h4 id="无符号数比较的jcc指令"><a href="#无符号数比较的jcc指令" class="headerlink" title="无符号数比较的jcc指令"></a>无符号数比较的<code>jcc</code>指令</h4><table>
<thead>
<tr>
<th style="text-align:center">jcc 指令</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">转移条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ja/jnbe</td>
<td style="text-align:center">高于（不低于等于）时转移</td>
<td style="text-align:center"><code>cf</code> = 0 且 <code>zf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jae/jnb</td>
<td style="text-align:center">高于等于（不低于）时转移</td>
<td style="text-align:center"><code>cf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">jb/jnae</td>
<td style="text-align:center">低于（不高于等于）时转移</td>
<td style="text-align:center"><code>cf</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">jbe/jna</td>
<td style="text-align:center">低于等于（不高于）时转移</td>
<td style="text-align:center"><code>cf</code> = 1 或 <code>zf</code> = 1</td>
</tr>
</tbody>
</table>
<h3 id="3-loop（循环）"><a href="#3-loop（循环）" class="headerlink" title="3. loop（循环）"></a>3. loop（循环）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">loop label</span>           <span class="comment">; cx=cx-1, 若cx!=0则转到label</span></div><div class="line"><span class="keyword">loopz</span>/<span class="keyword">loope</span> label    <span class="comment">; cx=cx-1，若cx!=0且zf=1则转到label</span></div><div class="line"><span class="keyword">loopnz</span>/<span class="keyword">loopne</span> label  <span class="comment">; cx=cx-1，若cx!=0且zf=0则转到label</span></div></pre></td></tr></table></figure>
<p>label的相对偏移量必须在-128~127之间</p>
<h3 id="4-call（调用）-ret（返回）"><a href="#4-call（调用）-ret（返回）" class="headerlink" title="4. call（调用）/ ret（返回）"></a>4. call（调用）/ ret（返回）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">call label</span>        <span class="comment">; 段内直接调用，ip入栈</span></div><div class="line"><span class="keyword">call</span> reg16/mem16  <span class="comment">; 段内间接调用，ip入栈</span></div><div class="line"><span class="keyword">call</span> mem32        <span class="comment">; 段间间接调用，cs和ip入栈</span></div></pre></td></tr></table></figure>
<p><code>CPU</code>执行<code>call</code>指令时，分两步操作：</p>
<ol>
<li>将<code>ip</code>（16位操作）或<code>cs</code>:<code>ip</code>（32位操作）入栈</li>
<li>转移</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ret</span>   <span class="comment">; 近转移</span></div><div class="line"><span class="keyword">retf</span>  <span class="comment">; 远转移</span></div></pre></td></tr></table></figure>
<p><code>CPU</code>执行<code>ret</code>指令时，相当于<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pop</span> <span class="built_in">ip</span></div></pre></td></tr></table></figure></p>
<p><code>CPU</code>执行<code>retf</code>指令时，相当于<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pop</span> <span class="built_in">ip</span></div><div class="line"><span class="keyword">pop</span> <span class="built_in">cs</span></div></pre></td></tr></table></figure></p>
<p><code>call</code>指令与<code>ret</code>指令必须配合使用。</p>
<h2 id="标志处理指令"><a href="#标志处理指令" class="headerlink" title="标志处理指令"></a>标志处理指令</h2><table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clc</td>
<td style="text-align:center"><code>cf</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">stc</td>
<td style="text-align:center"><code>cf</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">cmc</td>
<td style="text-align:center"><code>cf</code> = not <code>cf</code></td>
</tr>
<tr>
<td style="text-align:center">cld</td>
<td style="text-align:center"><code>df</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">std</td>
<td style="text-align:center"><code>df</code> = 1</td>
</tr>
<tr>
<td style="text-align:center">cli</td>
<td style="text-align:center"><code>if</code> = 0</td>
</tr>
<tr>
<td style="text-align:center">sti</td>
<td style="text-align:center"><code>if</code> = 1</td>
</tr>
</tbody>
</table>
<h2 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h2><p>串操作指令有以下特点：</p>
<ol>
<li>用 <code>si</code> 寄存器寻址源操作数，用 <code>di</code> 寄存器寻址目的操作数</li>
<li>源操作数隐含的段寄存器为 <code>ds</code>，但允许段超越；目的操作数的段寄存器约定为 <code>es</code>，不允许段超越</li>
<li>每当串操作指令执行后，自动执行源变址或目的变址，当 <code>df</code>=0 时，地址增量为正，否则为负。增量的大小与操作数类型有关，字节为1，字为2，双字为4</li>
</ol>
<p><em>※ 这也表明了为什么<code>si</code>是源变址寄存器，<code>di</code>是目的变址寄存器，而<code>ds</code>为数据段，<code>es</code>为附加段。</em></p>
<h3 id="1-rep（重复串操作直到cx为0）"><a href="#1-rep（重复串操作直到cx为0）" class="headerlink" title="1. rep（重复串操作直到cx为0）"></a>1. rep（重复串操作直到<code>cx</code>为0）</h3><p><code>rep</code>常与 [<code>movs</code>,<code>stos</code>,<code>lods</code>,<code>ins</code>,<code>outs</code>] 指令配合使用。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">rep</span> string op[movs/stos/lods/ins/outs]</div></pre></td></tr></table></figure></p>
<p>执行过程如下：</p>
<ol>
<li>若<code>cx</code>=0，退出<code>rep</code>，否则往下执行</li>
<li><code>dec</code> <code>cx</code></li>
<li>执行 <code>string op</code></li>
<li>返回 1</li>
</ol>
<h3 id="2-movs（串传送）"><a href="#2-movs（串传送）" class="headerlink" title="2. movs（串传送）"></a>2. movs（串传送）</h3><p><code>movs</code>后加上<code>b</code>,<code>w</code>等表示操作类型为<code>字节</code>，<code>字</code>。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">movsb</span> dst, src  <span class="comment">; 传送字节</span></div><div class="line"><span class="keyword">movsw</span> dst, src  <span class="comment">; 传送字</span></div></pre></td></tr></table></figure></p>
<p>作用： <code>es</code>:<code>[di]</code> = <code>ds</code>:<code>si</code>，将<code>ds</code>:<code>si</code>所指的串复制<code>cx</code>个字节/字到<code>es</code>:<code>di</code>所指的内存单元中，当<code>df</code>=0时，每次操作后<code>si</code>和<code>di</code>递增<code>size</code>，否则递减<code>size</code>。其中，<code>size</code>等于1（字节）或2（字）。</p>
<p>例：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code, <span class="built_in">ds</span>:data, <span class="built_in">es</span>:extra</div><div class="line"></div><div class="line">data <span class="meta">segment</span></div><div class="line">  srcstr <span class="built_in">db</span> <span class="string">'hello world!$'</span></div><div class="line">data ends</div><div class="line"></div><div class="line">extra <span class="meta">segment</span></div><div class="line">  dststr <span class="built_in">db</span> <span class="number">13</span> dup(<span class="number">0</span>)</div><div class="line">extra ends</div><div class="line"></div><div class="line">code <span class="meta">segment</span></div><div class="line"><span class="symbol">main:</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, data</div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, extra</div><div class="line">  <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></div><div class="line">  </div><div class="line">  <span class="keyword">lea</span> <span class="built_in">si</span>, srcstr</div><div class="line">  <span class="keyword">lea</span> <span class="built_in">di</span>, dststr</div><div class="line">  <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">13</span></div><div class="line">  <span class="keyword">cld</span></div><div class="line">  <span class="keyword">rep</span> <span class="keyword">movsb</span></div><div class="line">  </div><div class="line">  <span class="keyword">lea</span> <span class="built_in">dx</span>, dststr</div><div class="line">  <span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">9</span></div><div class="line">  <span class="keyword">int</span> <span class="number">21h</span></div><div class="line">  </div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></div><div class="line">  <span class="keyword">int</span> <span class="number">21h</span></div><div class="line">code ends</div><div class="line">end main</div></pre></td></tr></table></figure></p>
<h3 id="3-lods（串载入）-stos（串存储）"><a href="#3-lods（串载入）-stos（串存储）" class="headerlink" title="3. lods（串载入）/ stos（串存储）"></a>3. lods（串载入）/ stos（串存储）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lodsb</span>  <span class="comment">; 载入字节</span></div><div class="line"><span class="keyword">lodsw</span>  <span class="comment">; 载入字</span></div></pre></td></tr></table></figure>
<p>作用：将 <code>ds</code>:<code>si</code> 所指串的值复制到 <code>al</code>/<code>ax</code> 中，然后根据<code>df</code>增加或减少<code>si</code>。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">stosb</span>  <span class="comment">; 存入字节</span></div><div class="line"><span class="keyword">stosw</span>  <span class="comment">; 存入字</span></div></pre></td></tr></table></figure>
<p>作用：将 <code>al</code>/<code>ax</code> 的值 复制到 <code>es</code>:<code>di</code> 所指的内存单元中，然后根据<code>df</code>增加或减少<code>di</code>。</p>
<p>例：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code, <span class="built_in">es</span>:extra</div><div class="line"></div><div class="line">extra <span class="meta">segment</span></div><div class="line">  buf <span class="built_in">db</span> <span class="number">10</span> dup(<span class="number">0</span>)</div><div class="line">extra ends</div><div class="line"></div><div class="line">code <span class="meta">segment</span></div><div class="line"><span class="symbol">main:</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, extra</div><div class="line">  <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></div><div class="line">  </div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">20h</span></div><div class="line">  <span class="keyword">lea</span> <span class="built_in">di</span>, buf</div><div class="line">  <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">10</span></div><div class="line">  <span class="keyword">cld</span></div><div class="line">  <span class="keyword">rep</span> <span class="keyword">stosb</span></div><div class="line">  </div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></div><div class="line">  <span class="keyword">int</span> <span class="number">21h</span></div><div class="line">code ends</div><div class="line">end main</div></pre></td></tr></table></figure></p>
<h3 id="4-cmps（串比较）"><a href="#4-cmps（串比较）" class="headerlink" title="4. cmps（串比较）"></a>4. cmps（串比较）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cmpsb</span>  <span class="comment">; 比较源串与目的串的一个字节</span></div><div class="line"><span class="keyword">cmpsw</span>  <span class="comment">; 比较源串与目的串的一个字</span></div></pre></td></tr></table></figure>
<p>作用：将 <code>ds</code>:<code>si</code> 所指串的值与 <code>es</code>:<code>di</code> 所指串的值进行比较，并根据比较结果（两个值相减）设置标志位，然后，对 <code>si</code> 和 <code>di</code> 做相应的调整。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;控制转移指令&quot;&gt;&lt;a href=&quot;#控制转移指令&quot; class=&quot;headerlink&quot; title=&quot;控制转移指令&quot;&gt;&lt;/a&gt;控制转移指令&lt;/h2&gt;&lt;h3 id=&quot;1-jmp（无条件转移）&quot;&gt;&lt;a href=&quot;#1-jmp（无条件转移）&quot; class=&quot;head
    
    </summary>
    
      <category term="汇编" scheme="http://www.alinshans.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://www.alinshans.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编：指令系统（上）</title>
    <link href="http://www.alinshans.com/2017/05/30/p1705301/"/>
    <id>http://www.alinshans.com/2017/05/30/p1705301/</id>
    <published>2017-05-30T09:40:04.000Z</published>
    <updated>2017-06-09T14:02:01.829Z</updated>
    
    <content type="html"><![CDATA[<p>8086汇编常用的指令，从功能上分，一般分为：</p>
<ul>
<li>数据传送指令</li>
<li>算术指令</li>
<li>逻辑指令</li>
<li>控制转移指令</li>
<li>标志处理指令</li>
<li>串处理指令</li>
</ul>
<p>这些指令书上网上都有很多介绍，我就不会全部详细介绍，只挑一些常用的、需要注意的重点说明。</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="1-mov（传送）"><a href="#1-mov（传送）" class="headerlink" title="1. mov（传送）"></a>1. mov（传送）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> dst, src</div></pre></td></tr></table></figure>
<p>有以下需要注意的地方：</p>
<ol>
<li><p><code>dst</code> 和 <code>src</code> 类型必须匹配，无法确定类型时要显式指定类型。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1</span>               <span class="comment">; 正确！立即数会自动扩展类型</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bl</span>              <span class="comment">; 错误！类型不匹配</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="number">0</span>]             <span class="comment">; 可以运行，但不是预期结果，原因见 2</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]          <span class="comment">; 正确！ax是字类型，ds:[0]也获取字类型</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="number">1</span>           <span class="comment">; 错误！无法确定类型</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="number">1</span>  <span class="comment">; 正确！指定了访问的内存单元是一个字节单元</span></div></pre></td></tr></table></figure>
</li>
<li><p>形如 <code>mov ax, [0]</code> 这类指令 <code>Debug</code>加载运行 和 <code>masm</code>编译器对它们的解释不同，<code>Debug</code> 将<code>[idata]</code>解释为一个内存单元，<code>idata</code>是内存单元的偏移地址；而编译器将<code>[idata]</code>解释为<code>idata</code>，一个立即数。<br><img src="http://i4.buimg.com/594413/b0fb64f5450412e0.png" alt="Markdown"><br>所以，<strong>在汇编源程序中，要访问一个内存单元，并且 <code>[...]</code> 里面是一个立即数，必须要用以下两种方法</strong>：<br></p>
<ul>
<li><p>将偏移地址放进 <code>bx</code> 寄存器（或<code>si</code>,<code>di</code>）中，然后用 <code>[bx]</code> 来访问内存单元。（用 <code>bx</code>, <code>si</code>, <code>di</code> 时，默认段寄存器在 <code>ds</code> 中， 用 <code>bp</code> 时，默认段寄存器在 <code>ss</code> 中）</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">1</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>在 [] 前面显示指定段寄存器。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>dst</code> 和 <code>src</code> 不能同时为内存单元和段寄存器。</p>
</li>
<li><p>不能将立即数传给段寄存器，<strong>段名也是立即数</strong>，但可以将内存单元数据传给段寄存器。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code, <span class="built_in">ds</span>:data</div><div class="line"></div><div class="line">data <span class="meta">segment</span></div><div class="line">    address <span class="built_in">dw</span> <span class="number">1234h</span></div><div class="line">data ends</div><div class="line"></div><div class="line">code <span class="meta">segment</span></div><div class="line"><span class="symbol">main:</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="number">1234h</span>    <span class="comment">; 错误！不能将立即数传给段寄存器</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, data     <span class="comment">; 错误！段名也是一个立即数</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>        </div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, [<span class="built_in">bx</span>]     <span class="comment">; 可以</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, address  <span class="comment">; 可以，address会被编译成一个地址，同上一条指令类似</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></div><div class="line">    <span class="keyword">int</span> <span class="number">21h</span></div><div class="line">code ends</div><div class="line">end main</div></pre></td></tr></table></figure>
</li>
<li><p>目的操作数 <code>dst</code> 不能为立即数或 <code>cs</code>(代码段寄存器)。</p>
</li>
<li><code>mov</code> 指令不影响标志位。</li>
</ol>
<h3 id="2-push（入栈）-pop（出栈）"><a href="#2-push（入栈）-pop（出栈）" class="headerlink" title="2. push（入栈） / pop（出栈）"></a>2. push（入栈） / pop（出栈）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> reg16/segreg/mem16</div><div class="line"><span class="keyword">pop</span> reg16/segreg/mem16</div></pre></td></tr></table></figure>
<p><code>push</code> 和 <code>pop</code> 的操作数可以是16位寄存器、段寄存器或者字内存单元。注意：<strong>不能 <code>pop</code> 到 <code>cs</code>(代码段寄存器)中</strong>。</p>
<p>以下操作都是合法的：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="built_in">ax</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ds</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</div><div class="line"><span class="keyword">pop</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</div><div class="line"><span class="keyword">pop</span> <span class="built_in">ds</span></div><div class="line"><span class="keyword">pop</span> <span class="built_in">ax</span></div></pre></td></tr></table></figure></p>
<h3 id="3-xchg（交换）"><a href="#3-xchg（交换）" class="headerlink" title="3. xchg（交换）"></a>3. xchg（交换）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">xchg</span> object1, object2</div></pre></td></tr></table></figure>
<p>交换8/16位寄存器/内存单元的值。</p>
<p><strong>注意：</strong></p>
<ol>
<li>类型必须匹配。</li>
<li>交换数<strong>必须是</strong>通用寄存器（<code>AX</code>,<code>BX</code>,<code>CX</code>,<code>DX</code>,<code>SI</code>,<code>DI</code>）或内存单元。</li>
<li>两个交换数不能同时为内存单元。<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">xchg</span> <span class="built_in">al</span>, <span class="built_in">dl</span>                            <span class="comment">; 可以</span></div><div class="line"><span class="keyword">xchg</span> <span class="built_in">ax</span>, <span class="built_in">bx</span>                            <span class="comment">; 可以</span></div><div class="line"><span class="keyword">xchg</span> <span class="built_in">ax</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]               <span class="comment">; 可以</span></div><div class="line"><span class="keyword">xchg</span> [<span class="built_in">bx</span>], <span class="built_in">ax</span>                          <span class="comment">; 可以</span></div><div class="line"><span class="keyword">xchg</span> <span class="built_in">al</span>, <span class="built_in">bx</span>                            <span class="comment">; 错误！类型不匹配</span></div><div class="line"><span class="keyword">xchg</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>                            <span class="comment">; 错误！交换数不能为段寄存器</span></div><div class="line"><span class="keyword">xchg</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>                            <span class="comment">; 错误！交换数不能为段寄存器</span></div><div class="line"><span class="keyword">xchg</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">1</span>]  <span class="comment">; 错误！两个都是内存单元</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-lea（传入有效地址-Load-Effective-Address）"><a href="#4-lea（传入有效地址-Load-Effective-Address）" class="headerlink" title="4. lea（传入有效地址 Load Effective Address）"></a>4. lea（传入有效地址 Load Effective Address）</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span> reg16 mem</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>目的操作数必须为16位通用寄存器，不能是段寄存器</li>
<li>传入寄存器的是有效地址，而不是内容</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span> <span class="built_in">dx</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]  <span class="comment">; 可以</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">dx</span>, msg     <span class="comment">; 可以，类似于上一条指令</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">dl</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]  <span class="comment">; 错误！必须为16位通用寄存器</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">ds</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]  <span class="comment">; 错误！不能为段寄存器</span></div></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span> <span class="built_in">dx</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p><code>dx</code>中保存了<code>ds:[0]</code>的偏移地址，若想得到<code>ds:[0]</code>的值，要用：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="built_in">ds</span>:[<span class="number">0</span>]</div></pre></td></tr></table></figure></p>
<p>以下两条指令功能相同：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span> <span class="built_in">dx</span>, msg</div><div class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, offset msg</div></pre></td></tr></table></figure></p>
<h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><h4 id="1-add（加法）"><a href="#1-add（加法）" class="headerlink" title="1. add（加法）"></a>1. add（加法）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">add</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p>作用：<code>dst</code> = <code>dst</code> + <code>src</code><br><strong>注意：1） 两个操作数类型要匹配。 2）操作数不能同为内存单元。</strong></p>
<h4 id="2-adc（带进位加法）"><a href="#2-adc（带进位加法）" class="headerlink" title="2. adc（带进位加法）"></a>2. adc（带进位加法）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">adc</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p>作用：<code>dst</code> = <code>dst</code> + <code>src</code> + <code>cf</code><br><strong>注意：同 <code>add</code>。</strong></p>
<h4 id="3-inc（自增一）"><a href="#3-inc（自增一）" class="headerlink" title="3. inc（自增一）"></a>3. inc（自增一）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inc</span> reg/mem</div></pre></td></tr></table></figure>
<h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><h4 id="1-sub（减法）"><a href="#1-sub（减法）" class="headerlink" title="1. sub（减法）"></a>1. sub（减法）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sub</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p>作用：<code>dst</code> = <code>dst</code> - <code>src</code><br><strong>注意：同 <code>add</code>。</strong></p>
<h4 id="2-sbb（带借位减法）"><a href="#2-sbb（带借位减法）" class="headerlink" title="2. sbb（带借位减法）"></a>2. sbb（带借位减法）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sbb</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p>作用：<code>dst</code> = <code>dst</code> - <code>src</code> - <code>cf</code><br><strong>注意：同 <code>add</code>。</strong></p>
<h4 id="3-dec（自减一）"><a href="#3-dec（自减一）" class="headerlink" title="3. dec（自减一）"></a>3. dec（自减一）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dec</span> reg/mem</div></pre></td></tr></table></figure>
<h4 id="4-neg（求补）"><a href="#4-neg（求补）" class="headerlink" title="4. neg（求补）"></a>4. neg（求补）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">neg</span> reg/mem</div></pre></td></tr></table></figure>
<p>作用：<code>dst</code> = 0 - <code>dst</code> （即求相反数）</p>
<h4 id="5-cmp（比较）"><a href="#5-cmp（比较）" class="headerlink" title="5. cmp（比较）"></a>5. cmp（比较）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cmp</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p>作用：根据 <code>dst</code> - <code>src</code> 的结果去影响标志位。<br><strong>注意：同 <code>add</code>。</strong></p>
<h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><h4 id="1-mul（无符号乘法）"><a href="#1-mul（无符号乘法）" class="headerlink" title="1. mul（无符号乘法）"></a>1. mul（无符号乘法）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mul</span> reg/mem</div></pre></td></tr></table></figure>
<p>作用：1）当操作数为8位时，乘数默认保存在 <code>al</code> 中，结果保存在 <code>ax</code> 中，<code>ax</code> = <code>al</code> × <code>src</code>。2）当操作数为16位时，乘数默认保存在 <code>ax</code> 中，结果的高16位保存在 <code>dx</code> 中，低16位保存在 <code>dx</code> 中，<code>dx</code> : <code>ax</code> = <code>ax</code> × <code>src</code>。</p>
<h4 id="2-imul（带符号乘法）"><a href="#2-imul（带符号乘法）" class="headerlink" title="2. imul（带符号乘法）"></a>2. imul（带符号乘法）</h4><p>同 <code>mul</code>。</p>
<h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><h4 id="1-div（无符号除法）"><a href="#1-div（无符号除法）" class="headerlink" title="1. div（无符号除法）"></a>1. div（无符号除法）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">div</span> reg/mem</div></pre></td></tr></table></figure>
<p>作用：1）当操作数为8位时，被除数默认保存在 <code>ax</code> 中，结果商保存在 <code>al</code> 中，余数保存在 <code>ah</code> 中。2）当操作数为16位时，被除数默认高16位保存在 <code>dx</code> 中，低16位保存在 <code>ax</code> 中，结果商保存在 <code>ax</code> 中，余数保存在 <code>dx</code> 中。</p>
<h4 id="2-idiv（带符号除法）"><a href="#2-idiv（带符号除法）" class="headerlink" title="2. idiv（带符号除法）"></a>2. idiv（带符号除法）</h4><p>同 <code>div</code>。<br><strong>注意：除法指令可能会发生溢出，产生0号中断。可参考 <a href="http://www.doc88.com/p-5836860600548.html" target="_blank" rel="external">http://www.doc88.com/p-5836860600548.html</a> 。</strong></p>
<h2 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h2><h3 id="逻辑运行指令"><a href="#逻辑运行指令" class="headerlink" title="逻辑运行指令"></a>逻辑运行指令</h3><h4 id="1-and（与）-or（或）-not（非）-xor（异或）"><a href="#1-and（与）-or（或）-not（非）-xor（异或）" class="headerlink" title="1. and（与）/ or（或）/ not（非）/ xor（异或）"></a>1. and（与）/ or（或）/ not（非）/ xor（异或）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">and</span> reg/mem, reg/mem/idata</div><div class="line"><span class="keyword">or</span>  reg/mem, reg/mem/idata</div><div class="line"><span class="keyword">not</span> reg/mem</div><div class="line"><span class="keyword">xor</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p><strong>注意：1） 两个操作数类型要匹配。 2）操作数不能同为内存单元。</strong></p>
<h4 id="2-test（测试）"><a href="#2-test（测试）" class="headerlink" title="2. test（测试）"></a>2. test（测试）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">test</span> reg/mem, reg/mem/idata</div></pre></td></tr></table></figure>
<p>作用：将两个操作数相与（<code>and</code>）后的结果去影响标志位，若结果为0，则<code>zf</code>=1，否则<code>zf</code>=0。<br><strong>注意：1） 两个操作数类型要匹配。 2）操作数不能同为内存单元。</strong><br>常用用法：检查某位是否为1，e.g.:</p>
<ul>
<li><p>检验<code>ax</code>是否为负数</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">test</span> <span class="built_in">ax</span>, <span class="number">8000h</span></div><div class="line"><span class="keyword">jnz</span> l  <span class="comment">; 是负数则跳转</span></div></pre></td></tr></table></figure>
</li>
<li><p>检验<code>ax</code>是否为奇数</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">test</span> <span class="built_in">ax</span>, <span class="number">1</span></div><div class="line"><span class="keyword">jnz</span> l  <span class="comment">; 是奇数则跳转</span></div></pre></td></tr></table></figure>
</li>
<li><p>判断大小写</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">test</span> <span class="built_in">ax</span>, <span class="number">00100000b</span></div><div class="line"><span class="symbol">jz  label</span>1  <span class="comment">; 大写则跳转</span></div><div class="line"><span class="keyword">jmp</span> lable2  <span class="comment">; 小写则跳转</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><h4 id="shl（逻辑左移）-shr（逻辑右移）-sal（算术左移）-sar（算术右移）"><a href="#shl（逻辑左移）-shr（逻辑右移）-sal（算术左移）-sar（算术右移）" class="headerlink" title="shl（逻辑左移）/ shr（逻辑右移）/ sal（算术左移）/ sar（算术右移）"></a>shl（逻辑左移）/ shr（逻辑右移）/ sal（算术左移）/ sar（算术右移）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">shl</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div><div class="line"><span class="keyword">shr</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div><div class="line"><span class="keyword">sal</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div><div class="line"><span class="keyword">sar</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div></pre></td></tr></table></figure>
<p>作用：将操作数各个二进制位向左（右）移动1（<code>cl</code>）位，最高（低）位移出到 <code>cf</code>，最低（高）位补0（<code>sf</code>）。<br><strong>注意：1）若移位数为1，可以直接写1，否则必须将移位数放入<code>cl</code>中并调用。2）无论移动多少次，<code>cf</code>等于最后移出位的值。</strong><br><strong>逻辑移位跟算术移位的区别</strong>：算术移位是将数据看成是有正有负的补码数的运算，逻辑移位是将数据看成是无符号数。左移时，算术移位和逻辑移位最右端都是用0补充，操作相同，所以指令等价。右移时，算术右移最右端补<code>sf</code>（符号标志位），逻辑右移补0，所以指令不同。</p>
<h3 id="循环移位指令"><a href="#循环移位指令" class="headerlink" title="循环移位指令"></a>循环移位指令</h3><h4 id="rol（循环左移）-ror（循环右移）-rcl（带进位循环左移）-rcr（带进位循环右移）"><a href="#rol（循环左移）-ror（循环右移）-rcl（带进位循环左移）-rcr（带进位循环右移）" class="headerlink" title="rol（循环左移）/ ror（循环右移）/ rcl（带进位循环左移）/ rcr（带进位循环右移）"></a>rol（循环左移）/ ror（循环右移）/ rcl（带进位循环左移）/ rcr（带进位循环右移）</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">rol</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div><div class="line"><span class="keyword">ror</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div><div class="line"><span class="keyword">rcl</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div><div class="line"><span class="keyword">rcr</span> reg/mem, <span class="number">1</span>/<span class="built_in">cl</span></div></pre></td></tr></table></figure>
<p>作用：循环移位时，将操作数各个二进制位向左（右）移动1（<code>cl</code>）位，最高（低）位同时移入<code>cf</code>和最低（高）位。带进位循环移位时，将操作数各个二进制位向左（右）移动1（cl）位，最高（低）位移入<code>cf</code>，原<code>cf</code>移入最低（高）位。<br><strong>注意：同移位指令。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;8086汇编常用的指令，从功能上分，一般分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据传送指令&lt;/li&gt;
&lt;li&gt;算术指令&lt;/li&gt;
&lt;li&gt;逻辑指令&lt;/li&gt;
&lt;li&gt;控制转移指令&lt;/li&gt;
&lt;li&gt;标志处理指令&lt;/li&gt;
&lt;li&gt;串处理指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些指令
    
    </summary>
    
      <category term="汇编" scheme="http://www.alinshans.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://www.alinshans.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编：寄存器与寻址方式概述</title>
    <link href="http://www.alinshans.com/2017/05/29/p1705292/"/>
    <id>http://www.alinshans.com/2017/05/29/p1705292/</id>
    <published>2017-05-29T06:14:53.000Z</published>
    <updated>2017-05-29T15:54:23.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8086-计算机系统模型"><a href="#8086-计算机系统模型" class="headerlink" title="8086 计算机系统模型"></a>8086 计算机系统模型</h2><p><img src="http://i4.buimg.com/594413/a8c2fdc443111b52.gif" alt="8086 System Model"></p>
<p>通过系统总线，将计算机的各个部分链接在一起。<code>CPU</code> 则是这个体系的核心。</p>
<p><code>8086 CPU</code> 内部模型：</p>
<p><img src="http://i4.buimg.com/594413/1e35e99836b3d2c0.gif" alt="8086 CPU Model"></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><code>8086 CPU</code> 内部有14个可见的（程序员可操作）的寄存器，均为16位。分别为：AX, BX, CX, DX, SP, BP, SI, DI, IP, FLAG, CS, DS, SS, ES。这14个寄存器从用途上又分为三类：通用寄存器，控制寄存器和段寄存器。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>4个数据寄存器：AX, BX, CX, DX</p>
<ul>
<li>AX (Accumulator)：累加寄存器</li>
<li>BX (Base)：基址寄存器</li>
<li>CX (Count)：计数寄存器</li>
<li>DX (Data)：数据寄存器 </li>
</ul>
<p>这4个寄存器又可分为8个独立的8位寄存器：AH, BH, CH, DH, AL, BL, CL, DL。</p>
<p>2个指针寄存器：SP, BP</p>
<ul>
<li>SP (Stack Pointer)：堆栈指针寄存器</li>
<li>BP (Base Pointer)：基址指针寄存器</li>
</ul>
<p>2个变址寄存器：SI, DI</p>
<ul>
<li>SI (Source Index)：源变址寄存器</li>
<li>DI (Destination Index)：目的变址寄存器</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul>
<li>CS (Code Segment)：代码段寄存器</li>
<li>DS (Data Segment)：数据段寄存器</li>
<li>SS (Stack Segment)：堆栈段寄存器</li>
<li>ES (Extra Segment)：附加段寄存器</li>
</ul>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><ul>
<li>IP (Instruction Pointer)：指令指针寄存器</li>
<li>FLAG：标志寄存器</li>
</ul>
<h2 id="物理地址与有效地址"><a href="#物理地址与有效地址" class="headerlink" title="物理地址与有效地址"></a>物理地址与有效地址</h2><p><strong><code>物理地址(Physical Address)</code>就是CPU查找内存单元时的一个地址，它是唯一的</strong>。内存单元物理地址可由段址和段内的偏移量确定，<strong>内存单元在段内的偏移量就叫做<code>有效地址(Effective Address)</code></strong>。</p>
<p><code>8086 CPU</code>内部有20根地址线，其编码区间为：0000H~FFFFFH，所以，它的寻址能力（可直接访问的物理空间）为1M字节（2^20 bits）。但是<code>CPU</code>内部为16位的结构，如果用16位寄存器来访问内存的话，表现出来的寻址能力却只有64K。为了能用16位寄存器来有效地访问1M的存储空间，<code>CPU</code>内部采用了两个16位的地址来合成一个20位的物理地址。最终，<code>CPU</code>就采用下面这种方式来合成一个物理地址：</p>
<p><strong>物理地址 = 段地址 × 16 + 偏移地址</strong></p>
<p>这样的方式用汇编表现出来就是：</p>
<p><strong>段寄存器 : 偏移地址</strong></p>
<p>比如，<code>8086 CPU</code> 要访问物理地址为 <code>12000h</code>(十六进制)的内存单元，就可以把 <code>DS</code> 设为 <code>1000h</code>，把 <code>SI</code> 设为 <code>2000h</code>，然后通过 <code>DS:[SI]</code> 的方式表达，地址加法器就会按照上面的公式算出物理地址 = 1000h × 16 + 2000h = 12000h。</p>
<p>四个段寄存器就组成以下四种表达：</p>
<ul>
<li>CS : IP</li>
</ul>
<p>段寄存器<code>CS</code>指向存放程序的内存段，<code>IP</code>是用来存放下条待执行的指令在该段的偏移量，把它们合在一起可在该内存段内取到下次要执行的指令。</p>
<ul>
<li>DS : **</li>
</ul>
<p>段寄存器<code>DS</code>指向数据段，在存取操作数时，由<code>DS</code>和一个偏移量合成就可得到存储单元的物理地址。该偏移量可以是具体数值、符号地址和指针寄存器的值等之一，具体情况将由指令的寻址方式来决定。</p>
<ul>
<li>SS : SP</li>
</ul>
<p>段寄存器<code>SS</code>指向用于堆栈的内存段，<code>SP</code>是用来指向该堆栈的栈顶，把它们合在一起可访问栈顶单元。另外，当偏移量用到了指针寄存器<code>BP</code>，则其缺省的段寄存器也是<code>SS</code>，并且用<code>BP</code>可访问整个堆栈，不仅仅是只访问栈顶。</p>
<ul>
<li>ES : DI</li>
</ul>
<p>段寄存器<code>ES</code>指向附加数据段，也用于数据的保存，一般与<code>DS</code>用法类似，在进行串操作时，其目的地址的段寄存器规定为<code>ES</code>。</p>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>首先，要明确，什么是寻址方式。<strong>所谓寻址方式，就是讨论指令中操作数的来源问题</strong>。</p>
<p>根据操作数的不同来源来分类的话，寻址方式可以分为储存器方式和非储存器方式。下面着重讲 <code>8086/8088</code> 体系下的寻址方式。</p>
<p><code>8086 CPU</code> 有七种基本的寻址方式：</p>
<ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接寻址</li>
<li>寄存器间接寻址</li>
<li>寄存器相对寻址</li>
<li>基址变址寻址</li>
<li>相对基址变址寻址</li>
</ul>
<p>其中，前两种方式属于非储存器寻址方式，后五种属于储存器寻址方式。除了这些基本寻址方式，还有一些其它的寻址方式，如固定寻址、I/O端口寻址等，这些不会重点介绍。</p>
<p>为了总结方便，我<strong>费尽精力</strong>做了一个表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">指令特点</th>
<th style="text-align:center">举个栗子</th>
<th style="text-align:center">注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:center">用立即数给寄存器赋值</td>
<td style="text-align:center">mov ax, 1234h</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:center">源操作数为寄存器</td>
<td style="text-align:center">(1) mov num, ax<br>(2) mov ax, bx</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:center">括号内一个立即数</td>
<td style="text-align:center">(1) mov dx, [1000h]<br>(2) mov es:[1000h], dx</td>
<td style="text-align:center">使用<code>DS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:center">括号内一个基址或变址寄存器(<code>SI</code>,<code>DI</code>,<code>BX</code>,<code>BP</code>)</td>
<td style="text-align:center">(1) mov dx, [di]<br>(2) mov [bp], cx</td>
<td style="text-align:center">若有效地址在<code>SI</code>,<code>DI</code>和<code>BX</code>中，<br>则以<code>DS</code>作为缺省段寄存器；<br>若有效地址在<code>BP</code>中，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">寄存器相对寻址</td>
<td style="text-align:center">括号内一个基址或变址寄存器(<code>SI</code>,<code>DI</code>,<code>BX</code>,<code>BP</code>)+<br>一个立即数</td>
<td style="text-align:center">(1) mov ax, [bx+16]<br>(2) mov ax, 16[bx]<br>(3) mov es:[bx+5], al</td>
<td style="text-align:center">若<code>SI</code>,<code>DI</code>和<code>BX</code>作为有效地址的一部分，<br>则以<code>DS</code>作为缺省段寄存器；<br>若<code>BP</code>作为有效地址的一部分，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">基址变址寻址</td>
<td style="text-align:center">括号内一个基址寄存器(<code>BX</code>,<code>BP</code>)+<br>一个变址寄存器(<code>SI</code>,<code>DI</code>)</td>
<td style="text-align:center">(1) mov ax, [bx+si]<br>(2) mov ax, [si][bx]<br>(3) mov ds:[bp+si], al</td>
<td style="text-align:center">若<code>SI</code>,<code>DI</code>和<code>BX</code>作为有效地址的一部分，<br>则以<code>DS</code>作为缺省段寄存器；<br>若<code>BP</code>作为有效地址的一部分，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">相对基址变址寻址</td>
<td style="text-align:center">括号内一个基址寄存器(<code>BX</code>,<code>BP</code>)+<br>一个变址寄存器(<code>SI</code>,<code>DI</code>)+<br>一个立即数</td>
<td style="text-align:center">(1) mov ax, [bx+di+10h]<br>(2) mov ax, 10h[bx+di]<br>(3) mov ax, 10h[bx][di]<br>(4) mov ax, 10h[di][bx]</td>
<td style="text-align:center">若<code>SI</code>,<code>DI</code>和<code>BX</code>作为有效地址的一部分，<br>则以<code>DS</code>作为缺省段寄存器；<br>若<code>BP</code>作为有效地址的一部分，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;8086-计算机系统模型&quot;&gt;&lt;a href=&quot;#8086-计算机系统模型&quot; class=&quot;headerlink&quot; title=&quot;8086 计算机系统模型&quot;&gt;&lt;/a&gt;8086 计算机系统模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i4.buimg.com/
    
    </summary>
    
      <category term="汇编" scheme="http://www.alinshans.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://www.alinshans.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编：前言</title>
    <link href="http://www.alinshans.com/2017/05/29/p1705291/"/>
    <id>http://www.alinshans.com/2017/05/29/p1705291/</id>
    <published>2017-05-29T04:23:13.000Z</published>
    <updated>2017-05-29T15:54:20.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习汇编"><a href="#为什么要学习汇编" class="headerlink" title="为什么要学习汇编"></a>为什么要学习汇编</h2><p>我觉得，对于一个合格的、资深的程序员来说，学习汇编和理解汇编是必不可少的。这里的汇编不特指某一平台的汇编，但其实核心内容都一样。</p>
<p>原因如下：</p>
<ul>
<li>学习汇编帮助你理解高级语言的运行</li>
<li>深度调试时的需要</li>
<li>编译器不总是对的</li>
</ul>
<p>尤其是 C/C++ 这类的编程语言，有很多坑，而一些书或者人只告诉你不能这样做，但是为什么不能这样做，只有汇编才能告诉你。</p>
<p>还有比如程序优化，只有通过反汇编，你才能确定，程序优化的结果。</p>
<p>以及一些编译器的坑，编译器也是人写的，不能100%正确，那你怎么确定是你的问题还是编译器的问题？只有汇编能救你。</p>
<h2 id="学习汇编的好处"><a href="#学习汇编的好处" class="headerlink" title="学习汇编的好处"></a>学习汇编的好处</h2><p><a href="https://www.zhihu.com/people/skogkatt/answers" target="_blank" rel="external">@Skogkatt</a> 在 <a href="https://www.zhihu.com/question/23088538/answer/23717201" target="_blank" rel="external">这个回答</a> 说：</p>
<blockquote>
<p>学汇编不是说一定要用这玩艺做多牛鼻的事情, 问题的关键在于, 学透了汇编会使你真正理解计算机<br><br>另外一方面, 如上面所说, 在工作中你迟早会在某个阴暗的角落遇到汇编. 不管你承认不承认, 现在的CPU没有直接跑高级语言的, 哪怕是虚拟机也都是类似汇编的指令集.<br><br>当遇到崩溃分析, 性能优化甚至编译器抽风等等的时候, 汇编是你最后一根救命稻草.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要学习汇编&quot;&gt;&lt;a href=&quot;#为什么要学习汇编&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习汇编&quot;&gt;&lt;/a&gt;为什么要学习汇编&lt;/h2&gt;&lt;p&gt;我觉得，对于一个合格的、资深的程序员来说，学习汇编和理解汇编是必不可少的。这里的汇编不特指某
    
    </summary>
    
      <category term="汇编" scheme="http://www.alinshans.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://www.alinshans.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（附录一）</title>
    <link href="http://www.alinshans.com/2017/05/28/p1705282/"/>
    <id>http://www.alinshans.com/2017/05/28/p1705282/</id>
    <published>2017-05-28T02:53:04.000Z</published>
    <updated>2017-05-29T15:54:55.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6639526.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6639526.html</a> ，修改而成。</em></p>
</blockquote>
<p>这篇内容呀，其实是接<a href="http://www.cnblogs.com/GodA/p/6569254.html" target="_blank" rel="external">上一篇</a>的结尾提出的一个小问题而写的，如果你还没有看过那么你可以先看一下。</p>
<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>在上一篇的最后，我提到一个问题：代码优化。并留下了一个小小的测试：无符号数和有符号数的性能比较。不知道有没有童鞋去实验一下呢？那我们一起来做一个简单的实验：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*unsigned */</span><span class="keyword">int</span> a = <span class="number">123456789</span>;</div><div class="line">  <span class="keyword">auto</span> t1 = <span class="built_in">std</span>::chrono::system_clock::now();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</div><div class="line">  &#123;</div><div class="line">    a += <span class="number">3</span>;</div><div class="line">    a -= <span class="number">5</span>;</div><div class="line">    a *= <span class="number">11</span>;</div><div class="line">    a /= <span class="number">7</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> t2 = <span class="built_in">std</span>::chrono::system_clock::now();</div><div class="line">  <span class="keyword">auto</span> runtime = <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::nanoseconds&gt;(t2 - t1);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; runtime.count() &lt;&lt; <span class="string">"ns"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上述代码在 VS 的 <code>Debug</code> 模式下运行，稳定后运行时间在 210000ns 左右，然后把注释去掉，再次运行，稳定后运行时间也是 210000ns 左右。在我在电脑上，计算有符号类型和无符号类型几乎是没有差别的，我相信在绝大多数的电脑上也是相同的结果。</p>
<p>类似的问题还有：浮点数的计算比整型数慢？对于这个问题，可以看一下这个问题：<a href="https://www.zhihu.com/question/26494062" target="_blank" rel="external">https://www.zhihu.com/question/26494062</a> 。里面提供大量实验数据供参考。</p>
<p>无论如何，实际情况下就是，在当代，计算无符号数和有符号数的效率，甚至是计算浮点数和整数的效率，差异并不大。</p>
<p>我想说明什么呢？首先我要声明：我不是反对代码优化。而是对于有很多流传广泛的所谓的优化技巧，我觉得我们应该应该抱着学习探索的心态，而不是一味地追求一些没有什么意义的东西。有些优化，确实很精妙。但很多所谓的技巧，看起来的意思就是：做编译器的那群人都是傻逼。想优化我们的程序，这是正常的、应该的想法，但我们应该用科学的方法，而不是听了一些奇淫技巧，却不知道实际发生了什么。</p>
<p>其实很简单，探究性能瓶颈靠 <code>profiling</code>，探究代码背后的不为人知的故事看 <code>assembly</code>。我们先讲后面一个。</p>
<h2 id="利用-assembly-探究代码"><a href="#利用-assembly-探究代码" class="headerlink" title="利用 assembly 探究代码"></a>利用 <code>assembly</code> 探究代码</h2><p>怎么得到反汇编代码，我在 <a href="https://alinshans.github.io/2017/05/23/p1705231/" target="_blank" rel="external">这一篇</a> 当中有提到。比如我们研究有符号数和无符号数，先写一个程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*unsigned */</span><span class="keyword">int</span> a = <span class="number">123456789</span>;</div><div class="line">  a = a / <span class="number">13</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在 VS 下查看反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*unsigned */<span class="keyword">int</span> a = <span class="number">123456789</span><span class="comment">;</span></div><div class="line">00B4104E  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="number">75BCD15h</span>  </div><div class="line">  a = a / <span class="number">13</span><span class="comment">;</span></div><div class="line">00B41055  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [a]  </div><div class="line">00B41058  <span class="keyword">cdq</span>  </div><div class="line">00B41059  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">0Dh</span>  </div><div class="line">00B4105E  <span class="keyword">idiv</span>        <span class="built_in">eax</span>,<span class="built_in">ecx</span>  </div><div class="line">00B41060  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="built_in">eax</span></div></pre></td></tr></table></figure></p>
<p>把注释去掉再看：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">unsigned <span class="keyword">int</span> a = <span class="number">123456789</span><span class="comment">;</span></div><div class="line">00C3104E  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="number">75BCD15h</span>  </div><div class="line">  a = a / <span class="number">13</span><span class="comment">;</span></div><div class="line">00C31055  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [a]  </div><div class="line">00C31058  <span class="keyword">xor</span>         <span class="built_in">edx</span>,<span class="built_in">edx</span>  </div><div class="line">00C3105A  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">0Dh</span>  </div><div class="line">00C3105F  <span class="keyword">div</span>         <span class="built_in">eax</span>,<span class="built_in">ecx</span>  </div><div class="line">00C31061  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="built_in">eax</span></div></pre></td></tr></table></figure></p>
<p>几乎是一模一样的，最大的差别就是有符号数使用 idiv指令（带符号除法），无符号数使用 div指令（不带符号除法），而这两种指令，CPU 周期都是一样的。<a href="http://www.agner.org/optimize/instruction_tables.pdf" target="_blank" rel="external">http://www.agner.org/optimize/instruction_tables.pdf</a></p>
<p>当然我不是说不用无符号数，而是说我们用什么要看场合，而不是你觉得用了性能更好，除非是被大众认可的或者你经过严谨的测试的。像对于某些书籍或者什么地方说，只要确定范围不为负数的，就用无符号类型，我是不认可的。如果你讲范围，那如果一个有符号类型不够用，那么通常它对应的无符号类型(相同的 bits)也不够用。比如你 <code>std::int32_t</code> 不够用，就应该用 <code>std::int64_t</code>，如果还不够，考虑写个 <a href="https://github.com/Alinshans/redbud/blob/master/redbud/bignumber.h" target="_blank" rel="external">BigInteger类</a> 吧。不过对于无符号和有符号类型，它们之间的性能在当代确实是几乎没有什么差别。那具体什么场合用什么呢？这个也不一定，比如一般来说：</p>
<ul>
<li>对于位储存、位运算、模运算等，使用无符号类型</li>
<li>对于一般运算使用有符号类型</li>
</ul>
<p>这一篇的目的，当然不只是谈有符号数和无符号数，而是想借题引出一些我的看法：</p>
<ul>
<li>过早的优化是万恶之源</li>
<li>不要试图帮编译器优化</li>
<li>优化时不要去猜测，想当然得去优化自己“觉得”性能不好的地方</li>
</ul>
<p>我们一点一点讲。</p>
<p>对于一个需求，我们应该先完成功能，若性能达不到要求之后，在确定瓶颈之后再去优化。过早优化，不仅让代码不直接，还容易出 bug，还可能对性能几乎没有影响。而且，我们优化时，应该关注大方向，确定大方向是正确的。比如写一个算法，我们首先应该确保 <code>Big-O</code> 的时间复杂度能达标，可以用 <code>O(n)</code> 的就不用 <code>O(nlogn)</code>，可以用 <code>O(nlogn)</code> 的就不用 <code>O(n²)</code>，而不是先在那里扣 <code>i++</code> 还是 <code>++i</code>。另外，不要想着去帮编译器优化，因为编译器是一堆比你强不知道多少的人写出来的，而对于一般人，想着去帮编译器优化，大部分是无效的，甚至是错的。比如有人学了一点点的 <code>std::move</code>，就老是想着 move move move 去提高性能，举个栗子，容易写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">create</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">auto</span> object = <span class="keyword">new</span> T();</div><div class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(object);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>确实运行不会错，但是，代码背后做的事情不一定就跟你想的一样，往往跟你想象的还不一样。有些情况编译器可以采用更好的办法，结果因为你那么一搞，迫不得已只能采用次一点的办法。可以看看 <a href="https://www.zhihu.com/question/57048704" target="_blank" rel="external">这个问题</a>，就不赘述了。</p>
<p>还有比如说用异或来交换两个变量，有人会想，用位运算，不仅不需要创建临时变量，而且位运算一般不是更快嘛！对于这个问题，陈硕大大早有讲到，在 <a href="https://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf" target="_blank" rel="external">https://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf</a> 的第 9 章。可以去看一下。</p>
<p>如果你已经看了上面的链接，那么你也就知道了，你（几乎）不会知道编译器做了什么，编译器可以做的优化超出你的想象（不过有的时候人能明显看出来的优化编译器却做不到，但影响不大），在我的 <a href="https://alinshans.github.io/2017/05/23/p1705231/" target="_blank" rel="external">系列文章（二）</a> 中也有强调了，不要试图帮助编译器去优化。若你想探究一小段代码背后不为人知的故事，就去看看反汇编！</p>
<h2 id="利用-profiling-探究瓶颈"><a href="#利用-profiling-探究瓶颈" class="headerlink" title="利用 profiling 探究瓶颈"></a>利用 <code>profiling</code> 探究瓶颈</h2><p>关于这个问题，我想贴上一个链接，是 <a href="https://www.zhihu.com/people/lan-se-52-30/answers" target="_blank" rel="external">蓝色大大</a> 的一个回答：<a href="https://www.zhihu.com/question/56727144/answer/150555866" target="_blank" rel="external">https://www.zhihu.com/question/56727144/answer/150555866</a>。有非常详细清晰的介绍。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后我希望我放的链接都有认真看呀！为什么我贴那么多链接呢？因为我说的话没有权威没人信啊！但大牛们说的总有参考价值了吧！</p>
<p>暂时先写那么多，才学疏浅，如有不当地方还请海涵，感谢指点！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6639526.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://www.alinshans.com/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（三）</title>
    <link href="http://www.alinshans.com/2017/05/28/p1705281/"/>
    <id>http://www.alinshans.com/2017/05/28/p1705281/</id>
    <published>2017-05-28T02:01:33.000Z</published>
    <updated>2017-07-28T17:03:00.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6569254.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6569254.html</a> ，修改而成。</em></p>
</blockquote>
<p>这一篇会讲一个很小的点，但又经常容易犯错 ¯_(ツ)_/¯ ———— <strong><code>unsigned type</code></strong>。</p>
<h2 id="一、unsigned-type-的坑"><a href="#一、unsigned-type-的坑" class="headerlink" title="一、unsigned type 的坑"></a>一、unsigned type 的坑</h2><p>看到这篇的开头，你可能就会想，<code>unsigned type</code> 能有什么坑的呀！那我们就直接了当一些吧！</p>
<h3 id="1-小心可能陷入的死循环"><a href="#1-小心可能陷入的死循环" class="headerlink" title="1. 小心可能陷入的死循环"></a>1. 小心可能陷入的死循环</h3><p>其实单独的 <code>unsigned type</code> 你还是比较容易想明白的，怕的就是它跟一些其它东西搭配（比如 <code>auto</code>），而你又忽略了那就是 <code>unsigned type</code> 的时候，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> sz[] = <span class="string">"Hello world!"</span>;</div><div class="line">  <span class="comment">// 倒序输出字符串</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">std</span>::<span class="built_in">strlen</span>(sz) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sz[i];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于上述的代码，会有什么问题吗？当然啦，有些经验的人还是一眼就能看出来的，还有一些人需要多看两眼才能看出来。</p>
<p>问题就在于 <code>std::strlen</code> 的返回值类型是 <code>std::size_t</code> ，这是一个 <code>unsigned type</code>，而一个 <code>unsigned type</code> 的数值永远大于等于 0，是的没错，你很快就反应过来，死循环了。当然这个例子比较简单，而且如果你用 VS 这种有 <code>intelliSense</code> 的 IDE，你敲出函数，或者鼠标移到函数名字上，就能看到函数的声明。那万一不是用这种 IDE 的呢？又或者，一些你不认识的函数，而且类型也被 <code>typedef</code> 到你认不出来了，你又如何分辨呢？虽然这是简单的例子，但确实存在这种风险。</p>
<h3 id="2-小心可能的访问越界"><a href="#2-小心可能的访问越界" class="headerlink" title="2. 小心可能的访问越界"></a>2. 小心可能的访问越界</h3><p>其实上面的例子也是属于访问越界，但 C++ 的数组兼容 C，而 C 的数组是不作边界检查的，所以实际上，上述代码运行起来不会崩溃，甚至还不一定会出错。为什么说不一定呢，因为 <code>sz[-1]</code> 的内容是不知道的…所以输出也有可能让你撞对了，但是！这个<strong>代码一定是错误的</strong>。所以我会推荐使用 C++ 的容器，对于日常使用，已经绰绰有余了。C++ 的容器，在 <code>Debug</code> 模式下，是会做边界检查的。比如用 VS，在 <code>Debug</code> 下，容器访问越界了，它会有弹出一个 <code>MessageBox</code> 显示 <code>xxx subscript out of range</code> 之类的信息。</p>
<p>好了回归正题，使用容器时，要是一不小心，写出了类似代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就会导致了访问越界了，原因也是 <code>size()</code> 的返回类型是 <code>std::size_t</code> 。</p>
<p>之前我写一个 <a href="https://github.com/Alinshans/redbud/blob/master/redbud/bignumber.h" target="_blank" rel="external">BigInteger</a> 类的时候，就有很多用到了这样的倒序输出的地方。一开始没注意，也是出现了访问越界的错误，后来看到 <code>vector subscript out of range</code> 才反应过来。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>unsigned type</code> 的坑其实也不算很深，主要在于 0 这个点，要注意以下。解决的方案（至少）有以下几种：</p>
<h3 id="1-显示指定可容纳范围内的-signed-type"><a href="#1-显示指定可容纳范围内的-signed-type" class="headerlink" title="1. 显示指定可容纳范围内的 signed type"></a>1. 显示指定可容纳范围内的 <code>signed type</code></h3><p>如果你知道你数据的确切范围，比如不会超过 100w，那么就可以用一个能够放得下 100w 的一个 <code>signed type</code> 去指定它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div></pre></td></tr></table></figure></p>
<h3 id="2-手动做边界检查"><a href="#2-手动做边界检查" class="headerlink" title="2. 手动做边界检查"></a>2. 手动做边界检查</h3><p>如果你不能确定大小，而且不确定 signed type 能否容纳下那个 unsigned type 的全部范围，那就自己在循环的周围做一个边界检查：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (v.size() != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-把边界检查移到循环外部"><a href="#3-把边界检查移到循环外部" class="headerlink" title="3. 把边界检查移到循环外部"></a>3. 把边界检查移到循环外部</h3><p>其实是第2种方法的变形，如果你唯恐在循环内检查损失了很多性能，那么就可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (v.size() != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-使用-C-迭代器"><a href="#4-使用-C-迭代器" class="headerlink" title="4. 使用 C++ 迭代器"></a>4. 使用 C++ 迭代器</h3><p>既然用了 C++ 的容器，那么更好的写法当然是这样啦：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.rbegin(); i != v.rend(); ++i)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就不需要去考虑下标范围啦，什么检查啦，多方便！如果想写出更泛型，更有 C++ Style 的代码，还可以这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::rbegin(v), <span class="built_in">std</span>::rend(v), [&amp;](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>; &#125;);</div></pre></td></tr></table></figure></p>
<p>最终选择什么样的方式还是看实际情况跟个人爱好咯！</p>
<h2 id="三、其它杂谈"><a href="#三、其它杂谈" class="headerlink" title="三、其它杂谈"></a>三、其它杂谈</h2><p>我在网上看到不少关于什么“代码优化技巧”等等文章，即使是最近出的，还是这样写，也不知道是不是到处抄的。比如我看到<a href="http://www.codeceo.com/article/c-high-performance-coding.html" target="_blank" rel="external">其中一篇</a>就说到：</p>
<blockquote>
<p>有些处理器处理无符号unsigned 整形数的效率远远高于有符号signed整形数</p>
</blockquote>
<p>正确与否我就先不说了，错别字我也不去说了。留给读者先自己实验一下，我会在下一篇中用一篇来讨论一下这类问题。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>小标题即总结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6569254.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://www.alinshans.com/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（二）</title>
    <link href="http://www.alinshans.com/2017/05/23/p1705231/"/>
    <id>http://www.alinshans.com/2017/05/23/p1705231/</id>
    <published>2017-05-23T02:31:42.000Z</published>
    <updated>2017-07-28T17:03:15.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6554591.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6554591.html</a> ，修改而成。</em></p>
</blockquote>
<p>这一篇将会聊聊C++中一个极具迷惑性的关键字 ———— <strong>inline</strong>。<br>虽然只是一个小小的关键字，但要是没有真正了解它，也是很容易踩坑的。</p>
<h3 id="一、什么是-inline"><a href="#一、什么是-inline" class="headerlink" title="一、什么是 inline"></a>一、什么是 inline</h3><p>或许你对它有那么一点点熟悉，但是又说不清。它的中文翻译为“内联”。它经常跟一个东西共同出现，称为“内联函数(<a href="https://msdn.microsoft.com/en-us/library/bw1hbe6y.aspx" target="_blank" rel="external">inline function</a>)”。正是这样的翻译，对新手产生了太多的误会。那么什么是 inline 呢？现在暂时不做解答。接下来你可能会经常用到 <a href="http://en.cppreference.com/w/cpp/language/inline" target="_blank" rel="external">cppreference</a>，所以你可以先点开放到一旁，然后我们进入正题。</p>
<h3 id="二、inline-之初印象"><a href="#二、inline-之初印象" class="headerlink" title="二、inline 之初印象"></a>二、inline 之初印象</h3><p>上网搜一下，<a href="http://cn.bing.com/search?q=c%2b%2b+inline%e7%9a%84%e4%bd%9c%e7%94%a8&amp;qs=AS&amp;pq=c%2b%2b+inline+&amp;sk=AS1&amp;sc=8-11&amp;cvid=5A4D624B9B484EC384CAA3BBA9FC70A6&amp;FORM=QBRE&amp;sp=2" target="_blank" rel="external">C++ inline 的作用</a>，你看到的都是什么？都是说 inline 函数可以自动把函数展开呀，可以减小函数调用的开销呀……还会好心提醒你，太大的函数不宜用 inline 呀！会导致代码膨胀呀！只有那些短小精悍的、经常调用的函数使用 inline 才能看到非常明显的效果呀…………我在 N 年前，也是这么傻傻的，所以看到短函数就想加 inline，唯恐性能变差。于是，在印象里，<code>inline</code> 就跟<code>优化</code>挂上钩了。</p>
<h3 id="三、inline-之初体验"><a href="#三、inline-之初体验" class="headerlink" title="三、inline 之初体验"></a>三、inline 之初体验</h3><p>我们先从简单的例子开始，新建一个 <code>main.cpp</code> 源文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们编译运行，好，通过了。看到这个函数手痒了是吧，好我们给它加上 <code>inline</code>，再次编译运行，也通过了。到这里还没有问题，具体它的优化我们暂时不去分析。我们要养成一个工程习惯嘛！这是个简单的例子，但实际中我们写的代码可能很多，可能有很多很多个类似于 <code>max</code> 这样的函数，于是我们就想着把他们区分开，于是我们又创建了一个 <code>a.h</code> 头文件，把 <code>max</code> 扔进去，我们还想着接口与实现分离，于是我们创建一个 <code>a.cpp</code> 源文件来实现函数的定义，文件结构变成了这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.h</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们运行一遍，没有问题，然后我们试着给 <code>max</code> 函数加上 <code>inline</code>，你知道，<strong>Ⅰ.<code>inline</code> 要跟函数的定义放在一块</strong>，所以我们就要在 <code>a.cpp</code> 给它加上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>我们再次编译运行，WTF！！怎么报错了！！不就加了个 <code>inline</code> 吗？！！ 冷静了一会，我们看看报错信息，如果你用的是 VS，那么你大概会看到这样的提示：</p>
<pre><code>1&gt;main.obj : error LNK2019: 无法解析的外部符号 &quot;int __cdecl max(int,int)&quot; (?max@@YAHHH@Z)，该符号在函数 _main 中被引用
1&gt;C:\Users\Alinshans\documents\visual studio 2017\Projects\test\Debug\test.exe : fatal error LNK1120: 1 个无法解析的外部命令
</code></pre><p>是不是感觉有点熟悉？似曾相识？如果你用的是 G++ 去编译，那么大概会得到这样的提示：</p>
<pre><code>main.cpp:(.text+0x13): undefined reference to `max(int, int)&apos;
</code></pre><p>要是你对C/C++编译的过程有一点点了解的话，我们继续尝试用 G++ 去分别运行下面的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> g++ -c main.cpp</div><div class="line"><span class="meta">$</span> g++ main.o -o a.out</div></pre></td></tr></table></figure></p>
<p>你就会发现，运行第一条命令（编译）时，是没有错的，运行第二条命令（链接）时，就报错了。<br><img src="http://i4.buimg.com/594413/c1c976d3dff1de9f.png" alt="Markdown"><br>这里说明一下，大多数的建置环境都是在编译过程进行 inlining（为了替换函数调用，编译器需要知道函数的实体长什么样，这就解释了 Ⅰ），某些可以在连接期完成，少数的可以在运行期完成。我们只考虑绝大部分情况：inlining 在大多数C++程序中是编译期行为。<br>好了，我们讲回来，为什么会出现这个链接错误呢？注意到刚刚打开的网页 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">这里的第二、三条</a> ：</p>
<blockquote>
<p>2) The definition of an inline function or variable (since C++17) must be present in the translation unit where it is accessed (not necessarily before the point of access).<br>3) An inline function or variable (since C++17) with external linkage (e.g. not declared <code>static</code>) has the following additional properties:<br>  1) It must be declared <code>inline</code> in every translation unit.<br>  2) It has the same address in every translation unit.</p>
</blockquote>
<p>这里提到了 <code>external linkage</code>，若想详细了解可以看 <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Linkage" target="_blank" rel="external">这里</a>。嫌太长不看的你只需要知道我们定义的 <code>max</code> 函数，具有 <code>external linkage</code>，那么它就要满足：</p>
<ul>
<li>在你需要引用它的编译单元可见</li>
<li>在每个编译单元都要声明为 <code>inline</code></li>
</ul>
<p>用人话讲就是，你要把这个 inline function 的定义放到每一个你需要引用的 <code>.cpp(.cc/.cxx等)</code> 源文件。也就是说你要把 <code>main.cpp</code> 写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，这下就没问题了，可以编译通过了。但是，这就需要我们把在源文件内声明为 <code>inline</code> 的函数，复制到每一个需要引用的单元，这样可不好看。所以，一般情况下，<strong>Ⅱ. <code>inline</code> 函数的定义放在头文件中，而不放在源文件中</strong>。</p>
<h3 id="四、inline-之再体验"><a href="#四、inline-之再体验" class="headerlink" title="四、inline 之再体验"></a>四、inline 之再体验</h3><p>经过刚刚的了解，我们就试一试在头文件中给函数加上或不加上 <code>inline</code> 的区别吧！我们在 <code>a.h</code> 中新增一个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.h</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，<code>a.cpp</code> 文件依然没有变：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>main.cpp</code> 中引用这个 <code>min</code> 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="keyword">int</span> res2 = min(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">" "</span> &lt;&lt; res2 &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好我们编译运行一下，很好通过了，没有什么问题。我们试试看去掉 <code>inline</code> 会有什么区别吧！<br>WTF!!!怎么又报错了！？？这次又是什么鬼！？这一次，VS的提示是：</p>
<pre><code>1&gt;main.obj : error LNK2005: &quot;int __cdecl min(int,int)&quot; (?min@@YAHHH@Z) 已经在 a.obj 中定义
1&gt;C:\Users\Alinshans\documents\visual studio 2017\Projects\test\Debug\test.exe : fatal error LNK1169: 找到一个或多个多重定义的符号
</code></pre><p>是不是感觉也似曾相识？（<em>注意，若使用G++编译运行时，可能没有报错，并且正常运行，但这不是值得侥幸的</em>）我们稍微思考一下就能想明白：在 <code>a.h</code> 中定义了 <code>min</code> 这个函数，而在 <code>main.cpp</code> 中，又 <code>#include</code> 了 <code>a.h</code> 这个文件，其中 <code>a.cpp</code> 这个编译单元在生成 <code>a.obj</code> 时会为 <code>min</code> 生成一个实体，而 <code>main.cpp</code> 又为 <code>min</code> 生成了一个实体，所以就会出现重定义。<br>那为什么我们使用 <code>inline</code> 时，就不会有这个错误呢？</p>
<h3 id="五、什么时候应该使用-inline"><a href="#五、什么时候应该使用-inline" class="headerlink" title="五、什么时候应该使用 inline"></a>五、什么时候应该使用 inline</h3><p>我们还是翻到刚刚的链接，看到 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">第一条</a>：</p>
<blockquote>
<p>1) There may be more than one definition of an inline function or variable (since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables (since C++17)) all definitions are identical. For example, an inline function or an inline variable (since C++17) may be defined in a header file that is #include’d in multiple source files.</p>
</blockquote>
<p>用人话说就是声明为 <code>inline</code> 的函数可以在多个编译单元中重复定义，且只会为它们生成一份实体。<br>刚刚我们在 <code>a.h</code> 内定义的函数，就必须要加上 <code>inline</code> 声明（或者<code>static</code>也是可以的，这里不展开了）。<br>所以，<strong>Ⅲ. 当且仅当函数定义在头文件且有可能被多个源文件包含时，使用 <code>inline</code></strong> 。</p>
<h3 id="六、inline-与类成员函数、模板"><a href="#六、inline-与类成员函数、模板" class="headerlink" title="六、inline 与类成员函数、模板"></a>六、inline 与类成员函数、模板</h3><p>这个部分应该也是很让新手纠结的。因为一个类，可能会有很多 getter/setter 之类的短小的函数，于是就会去纠结要不要加 <code>inline</code>。同时类的成员函数定义的位置，也有以下三种（假设类的声明在 <code>a.h</code>，定义在 <code>a.cpp</code>）：</p>
<ul>
<li>在头文件中，定义在类中</li>
<li>在头文件中，定义在类外</li>
<li>在源文件中</li>
</ul>
<p>我们一个一个来谈谈。首先是定义在类中的，需不需要加 <code>inline</code> 呢？还是看到刚刚的页面，<a href="http://en.cppreference.com/w/cpp/language/inline" target="_blank" rel="external">最上面这里</a>：</p>
<blockquote>
<p>A function defined entirely inside a class/struct/union definition, whether it’s a member function or a non-member <code>friend</code> function, is implicitly an inline function. </p>
</blockquote>
<p>定义在类中的函数，是隐式 <code>inline</code> 的，所以不需要你加 <code>inline</code>，而且，<a href="http://llvm.org/docs/CodingStandards.html#don-t-use-inline-when-defining-a-function-in-a-class-definition" target="_blank" rel="external">LLVM CodingStandards</a> 也是这样提出的：</p>
<blockquote>
<p>Don’t use inline when defining a function in a class definition</p>
</blockquote>
<p>我们再讲讲定义在源文件中的，要是你认真看过本文，你就会知道，前面说了，不要把 inline 函数定义在源文件中，所以如果你类成员函数定义在了源文件中，也不需要加 <code>inline</code>。<br>剩下一个，其实我想不到什么理由，可以让成员函数既不定义在类内，也不定义在源文件中（<strong>模板类成员函数/类模板成员函数除外</strong>）。如果成员函数比较短小，那么你就可以直接定义在类内，否则可以定义在源文件中。而要是非得要定义在头文件且在类外，那就必须要声明为 <code>inline</code>，否则也会有一个重定义的错误。但为什么不直接定义在类中呢？<br>所以综上所述，<strong>Ⅳ. 不要把 <code>inline</code>用于类成员函数</strong>。</p>
<p>然后再讲模板，包括了函数模板、类模板成员函数和模板类成员函数。有点晕是吧，反正就是有带模板的函数。这些函数具有 <code>inline</code> 语义，是自带 <code>inline</code> 属性的。也就是说，你把刚刚的那个 <code>a.h</code> 文件里的 <code>min</code> 函数改成模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不需要加上 <code>inline</code>，也是可以正常运行的。所以，<strong>Ⅴ. 模板不需要声明为 <code>inline</code>，也具有 <code>inline</code> 的语义</strong>。</p>
<h3 id="七、inline-与优化"><a href="#七、inline-与优化" class="headerlink" title="七、inline 与优化"></a>七、inline 与优化</h3><p>刚刚说了 <code>inline</code> 的用法，现在终于到了要摧毁印象的时候了。我们就先用 <code>main.cpp</code> 来测试：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，<code>max</code> 函数是声明为 <code>inline</code> 的，我们可以看反汇编代码，来看看 <code>max</code> 是否有调用。使用 GCC，可以分别运行以下三条命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> g++ -E main.cpp -o main.i</div><div class="line"><span class="meta">$</span> g++ -S main.i -o main.s</div><div class="line"><span class="meta">$</span> g++ -O2 -S main.i -o main2.s</div></pre></td></tr></table></figure></p>
<p>然后 <code>main.s</code> 和 <code>main2.s</code> 就是分别未使用优化和 使用了<code>O2</code>优化后的反汇编代码。<br>在 VS 下看反汇编就非常简单了，随便设置一个断点，然后点<code>调试</code>-&gt;<code>开始调试</code>，等程序运行后，点<code>调试</code>-&gt;<code>窗口</code>-&gt;<code>反汇编</code>，就可以看到反汇编代码了。因为 VS 的反汇编的代码比较清晰好看，所以就以 VS 中的反汇编为例。<br>我们先在 <code>Debug</code> 模式下，查看反汇编代码（主要部分）：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></div><div class="line">002218AE  <span class="keyword">push</span>        <span class="number">2</span>  </div><div class="line">002218B0  <span class="keyword">push</span>        <span class="number">1</span>  </div><div class="line">002218B2  <span class="keyword">call</span>        max (<span class="number">02212BCh</span>)  </div><div class="line">002218B7  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span>  </div><div class="line">002218BA  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [res],<span class="built_in">eax</span>  </div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, res)<span class="comment">;</span></div><div class="line">002218BD  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [res]  </div><div class="line">002218C0  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">002218C1  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0227B30h</span>)  </div><div class="line">002218C6  <span class="keyword">call</span>        _printf (<span class="number">022132Fh</span>)  </div><div class="line">002218CB  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>我们可以看到，是有调用 <code>max</code> 函数的。我们再切换到 <code>Release</code> 模式，查看反汇编代码：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, res)<span class="comment">;</span></div><div class="line"><span class="number">00131040</span>  <span class="keyword">push</span>        <span class="number">2</span>  </div><div class="line"><span class="number">00131042</span>  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">01320F8h</span>)  </div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, res)<span class="comment">;</span></div><div class="line"><span class="number">00131047</span>  <span class="keyword">call</span>        printf (<span class="number">0131010h</span>)  </div><div class="line">0013104C  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>是的，<code>max</code> 函数的调用已经不见了，不过你认为这是拜你加上的 <code>inline</code> 所赐的吗？我们去掉 <code>inline</code> ，再重复一遍刚刚的过程，你会发现，结果是一模一样的。<br>你没有死心，说，这个函数太简单了，我是编译器我也能看得出来怎么优化，要是函数复杂一点，比如有循环、递归什么的，编译器就不会自动优化了！<br>那好吧，我们把 <code>main.cpp</code> 改成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</div><div class="line">  &#123;</div><div class="line">    x += j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, test(<span class="number">100</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>Debug</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">010118AE  <span class="keyword">push</span>        <span class="number">64h</span>  </div><div class="line">010118B0  <span class="keyword">call</span>        <span class="keyword">test</span> (<span class="number">0101136Bh</span>)  </div><div class="line">010118B5  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">4</span>  </div><div class="line">010118B8  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">010118B9  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">01017B30h</span>)  </div><div class="line">010118BE  <span class="keyword">call</span>        _printf (<span class="number">0101132Fh</span>)  </div><div class="line">010118C3  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>在 <code>Release</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00F31042  <span class="keyword">xor</span>         <span class="built_in">ecx</span>,<span class="built_in">ecx</span>  </div><div class="line">00F31044  <span class="keyword">xor</span>         <span class="built_in">eax</span>,<span class="built_in">eax</span>  </div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00F31046  <span class="keyword">xor</span>         <span class="built_in">edx</span>,<span class="built_in">edx</span>  </div><div class="line">00F31048  <span class="keyword">xor</span>         <span class="built_in">esi</span>,<span class="built_in">esi</span>  </div><div class="line">00F3104A  <span class="keyword">xor</span>         <span class="built_in">edi</span>,<span class="built_in">edi</span>  </div><div class="line">00F3104C  <span class="keyword">nop</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </div><div class="line">00F31050  <span class="keyword">inc</span>         <span class="built_in">edi</span>  </div><div class="line">00F31051  <span class="keyword">add</span>         <span class="built_in">esi</span>,<span class="number">2</span>  </div><div class="line">00F31054  <span class="keyword">add</span>         <span class="built_in">edx</span>,<span class="number">3</span>  </div><div class="line">00F31057  <span class="keyword">add</span>         <span class="built_in">ecx</span>,<span class="built_in">eax</span>  </div><div class="line">00F31059  <span class="keyword">add</span>         <span class="built_in">edi</span>,<span class="built_in">eax</span>  </div><div class="line">00F3105B  <span class="keyword">add</span>         <span class="built_in">esi</span>,<span class="built_in">eax</span>  </div><div class="line">00F3105D  <span class="keyword">add</span>         <span class="built_in">edx</span>,<span class="built_in">eax</span>  </div><div class="line">00F3105F  <span class="keyword">add</span>         <span class="built_in">eax</span>,<span class="number">4</span>  </div><div class="line">00F31062  <span class="keyword">cmp</span>         <span class="built_in">eax</span>,<span class="number">64h</span>  </div><div class="line">00F31065  <span class="keyword">jl</span>          main+<span class="number">10h</span> (<span class="number">0F31050h</span>)  </div><div class="line">00F31067  <span class="keyword">lea</span>         <span class="built_in">eax</span>,[<span class="built_in">edx</span>+<span class="built_in">esi</span>]  </div><div class="line">00F3106A  <span class="keyword">add</span>         <span class="built_in">eax</span>,<span class="built_in">edi</span>  </div><div class="line">00F3106C  <span class="keyword">add</span>         <span class="built_in">ecx</span>,<span class="built_in">eax</span>  </div><div class="line">00F3106E  <span class="keyword">push</span>        <span class="built_in">ecx</span>  </div><div class="line">00F3106F  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0F320F8h</span>)  </div><div class="line">00F31074  <span class="keyword">call</span>        printf (<span class="number">0F31010h</span>)  </div><div class="line">00F31079  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>喔，不要看它这么长，其实它是直接算出结果的了，所以已经没有 <code>test</code> 的调用了。这次看用G++生成的反汇编会更清晰一些：<br>不开优化：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line"><span class="symbol">.LFB1022:</span></div><div class="line"><span class="meta">	.cfi_startproc</span></div><div class="line">	pushq	%rbp</div><div class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></div><div class="line"><span class="meta">	.cfi_offset</span> <span class="number">6</span>, -<span class="number">16</span></div><div class="line">	<span class="keyword">movq</span>	%rsp, %rbp</div><div class="line"><span class="meta">	.cfi_def_cfa_register</span> <span class="number">6</span></div><div class="line">	movl	<span class="number">$100</span>, %edi</div><div class="line">	<span class="keyword">call</span>	_Z4testi</div><div class="line">	movl	%eax, %esi</div><div class="line">	movl	$.LC0, %edi</div><div class="line">	movl	<span class="number">$0</span>, %eax</div><div class="line">	<span class="keyword">call</span>	printf</div><div class="line">	movl	<span class="number">$0</span>, %eax</div><div class="line">	popq	%rbp</div><div class="line"><span class="meta">	.cfi_def_cfa</span> <span class="number">7</span>, <span class="number">8</span></div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>开O2优化：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line"><span class="symbol">.LFB1022:</span></div><div class="line"><span class="meta">	.cfi_startproc</span></div><div class="line">	subq	<span class="number">$8</span>, %rsp</div><div class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></div><div class="line">	movl	<span class="number">$4950</span>, %esi</div><div class="line">	movl	$.LC1, %edi</div><div class="line">	xorl	%eax, %eax</div><div class="line">	<span class="keyword">call</span>	printf</div><div class="line">	xorl	%eax, %eax</div><div class="line">	addq	<span class="number">$8</span>, %rsp</div><div class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">8</span></div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>看到了吧，这一次的 <code>test</code> 函数，我没有加 <code>inline</code>，在开启编译器优化的情况下，它还是可以自动去优化的。<br>你还会说，那啥，那啥……你还想说什么，自己去验证吧。我可以做最后一个实验。<br>现在把 <code>main.cpp</code> 改成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> prime[<span class="number">100</span>];</div><div class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= i; ++n)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">bool</span> is_prime = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(n)); ++j)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (n % j == <span class="number">0</span>)</div><div class="line">      &#123;</div><div class="line">        is_prime = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (is_prime)</div><div class="line">    &#123;</div><div class="line">      prime[k] = n;</div><div class="line">      ++k;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; k; ++n)</div><div class="line">  &#123;</div><div class="line">    sum += prime[n];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, test(<span class="number">100</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯…是有点儿长，我可是把 <code>test</code> 函数声明为 <code>inline</code> 的！然后在 <code>Debug</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00131ABE  <span class="keyword">push</span>        <span class="number">64h</span>  </div><div class="line">00131AC0  <span class="keyword">call</span>        <span class="keyword">test</span> (<span class="number">013102Dh</span>)  </div><div class="line">00131AC5  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">4</span>  </div><div class="line">00131AC8  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">00131AC9  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0137B30h</span>)  </div><div class="line">00131ACE  <span class="keyword">call</span>        _printf (<span class="number">0131339h</span>)  </div><div class="line">00131AD3  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>在 <code>Release</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00FC1170  <span class="keyword">call</span>        <span class="keyword">test</span> (<span class="number">0FC1040h</span>)  </div><div class="line">00FC1175  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">00FC1176  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0FC20F8h</span>)  </div><div class="line">00FC117B  <span class="keyword">call</span>        printf (<span class="number">0FC1010h</span>)  </div><div class="line">00FC1180  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>我声明了 <code>inline</code>，可是无论开不开优化，它也不帮我优化了。</p>
<h3 id="八、inline-的真正意义"><a href="#八、inline-的真正意义" class="headerlink" title="八、inline 的真正意义"></a>八、inline 的真正意义</h3><p>现在你该停下来思考思考了，什么是 <code>inline</code>？是“内联”吗？<code>inline</code> 的意义是什么？发起一个“内联”请求吗？<br>但事实上，你会发现，有时候，你不用 <code>inline</code>，会报错；有时候，你用了 <code>inline</code>，又会报错。你期望使用 <code>inline</code> 可以优化程序效率，但貌似跟你加不加 <code>inline</code> 没有什么关系啊？<br><code>inline</code> 的意义，似乎与“内联”，已经渐行渐远了。</p>
<p>好好的思考一下。<br><img src="http://i1.piimg.com/594413/4af9ac37c897da89.png" alt="Markdown"></p>
<p>我们还是继续翻开我们的 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">cppreference</a>，注意到这里有一段话：</p>
<blockquote>
<p>The original intent of the inline keyword was to serve as an indicator to the optimizer that inline substitution of a function is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (copying the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.<br>Since this meaning of the keyword <code>inline</code> is non-binding, compilers are free to use inline substitution for any function that’s not marked inline, and are free to generate function calls to any function marked inline. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above. </p>
</blockquote>
<p>看不懂没关系，其实它就是说：在很久很久以前，<code>inline</code> 作为给编译器优化的提示符，而 <code>inline</code> 的含义是非绑定的，编译器可以自由的选择、决定是否 inline 一个函数。而如今，编译器根本不需要这样的提示，如果它认为一个函数值得 inline，它会自动 inline，否则，即使你 inline 了，它也会拒绝。<br>可以看看这一篇 <a href="https://stackoverflow.com/questions/1759300/when-should-i-write-the-keyword-inline-for-a-function-method/1759575#1759575" target="_blank" rel="external">SO上的回答</a>：</p>
<blockquote>
<p>It is said that inline hints to the compiler that you think the function should be inlined. That may have been true in 1998, but a decade later the compiler needs no such hints. Not to mention humans are usually wrong when it comes to optimizing code, so most compilers flat out ignore the ‘hint’.</p>
<ul>
<li><code>static</code> - the variable/function name cannot be used in other compilation units. Linker needs to make sure it doesn’t accidentally use a statically defined variable/function from another compilation unit.</li>
<li><code>extern</code> - use this variable/function name in this compilation unit but don’t complain if it isn’t defined. The linker will sort it out and make sure all the code that tried to use some extern symbol has its address.</li>
<li><code>inline</code> - this function will be defined in multiple compilation units, don’t worry about it. The linker needs to make sure all compilation units use a single instance of the variable/function.</li>
</ul>
</blockquote>
<p>现在你应该差不多能够理解了，现在的编译器，并不需要你用 <code>inline</code> 去提醒，不要小看搞编译器那帮人，想着帮编译器优化的，一般人往往是错误的。所以，<strong>Ⅵ. 当且仅当你想用 <code>inline</code> 去优化程序时，不要使用 <code>inline</code></strong>。<br><code>inline</code> 这个关键字的翻译，就是一个坑，它真正的意义并不是去内联一个函数，而是表示 <strong><em>哥，别怕！无论你看到了多少个定义，但实体就我一个！</em></strong><br>在这个 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">cppreference</a> 里，最重要的就是这一句话：</p>
<blockquote>
<p>Because the meaning of the keyword inline for functions came to mean “multiple definitions are permitted” rather than “inlining is preferred”, that meaning was extended to variables. </p>
</blockquote>
<p>翻译过来就是：<strong>Ⅶ. <code>inline</code> 的含义更多的是“允许多重定义”而不是“优先选择内联”</strong>。</p>
<p>最后希望看完这篇文章的童鞋们，都可以深刻的理解C++的<code>inline</code>。</p>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><ul>
<li>Ⅰ.<code>inline</code> 要跟函数的定义放在一块</li>
<li>Ⅱ. <code>inline</code> 函数的定义放在头文件中，而不放在源文件中</li>
<li>Ⅲ. 当且仅当函数定义在头文件且有可能被多个源文件包含时，使用 <code>inline</code></li>
<li>Ⅳ. 不要把 <code>inline</code>用于类成员函数</li>
<li>Ⅴ. 模板不需要声明为 <code>inline</code>，也具有 <code>inline</code> 的语义</li>
<li>Ⅵ. 当且仅当你想用 <code>inline</code> 去优化程序时，不要使用 <code>inline</code></li>
<li>Ⅶ. <code>inline</code> 的含义更多的是“允许多重定义”而不是“优先选择内联”</li>
</ul>
<p>※注：以上总结适用于不熟悉、不了解 inline 的同学。若对以上内容都了解，使用 inline 的时候，很明白很清楚在做什么，会发生什么，那就随便怎么用啦！有的时候用了，就是为了好看一点呀！(～￣▽￣)～ </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6554591.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://www.alinshans.com/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（一）</title>
    <link href="http://www.alinshans.com/2017/05/22/p1705221/"/>
    <id>http://www.alinshans.com/2017/05/22/p1705221/</id>
    <published>2017-05-22T01:53:51.000Z</published>
    <updated>2017-07-28T17:03:07.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6501505.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6501505.html</a> ，修改而成。</em></p>
</blockquote>
<p>这一篇聊聊关于C++中的名称空间（namespace）。</p>
<h3 id="一、避免在全局范围内使用-using-namespace-xxx"><a href="#一、避免在全局范围内使用-using-namespace-xxx" class="headerlink" title="一、避免在全局范围内使用 using namespace xxx"></a>一、避免在全局范围内使用 using namespace xxx</h3><p>注意这个标题中的限定词，<strong>避免</strong>在<strong>全局范围内</strong>使用。什么意思呢？比如在头文件中，直接使用 <code>using namespace std</code> 之类的声明，这样是不好的。除非除非，你是最终代码用户，写一个小练习，小测试，否则都不要这么做。之前很喜欢写代码开头就写上 <code>using namespace std</code>，因为可以省很多事，比写什么 <code>cout</code>，<code>endl</code> 方便多了。后来我在写 <a href="https://github.com/Alinshans/MyTinySTL" target="_blank" rel="external">MyTinySTL</a> 这个项目时，最后写测试，为了方便，就用了 <code>using namespace std</code>，写的时候是挺爽的，一运行就炸了。错误长的惨不忍睹，一大堆的名称冲突。当你使用了 <code>using namespace std</code> 的时候，就把 <code>std</code> 这个名称空间内的内容直接引用到了当前空间，如果跟当前空间的函数、类等重名了，那么编译就不通过了，这个就叫<code>名称污染</code>。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> your</div><div class="line">&#123;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="built_in">vector</span>() = <span class="keyword">default</span>;</div><div class="line">  ~<span class="built_in">vector</span>() = <span class="keyword">default</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  T* data;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> your;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你编译它，就会得到类似不明确的符号 vector 啊，may be <code>std::vector</code> or <code>your::vector</code> 啊之类的。当然了，这太明显了，谁都会看出来。问题就在于，我们不能把问题是否发生，寄托于我们是否能够看出来。当代码多了，文件多了，几十个几百个，上万行十万行，你确定你还记得你在哪个头文件 using 了什么东西？然后在一层一层 include 的情况下，莫名其妙的就炸掉了。所以，还是从根源上杜绝问题比较好。</p>
<p>刚刚说的是 namespace std，但对于其它的 namespace 而言，也是一样的。如果是你自己写的，你都尚未能保证你能避开所有重复的命名，除非你自己写个玩具中的 demo，如果是别人写的，那就更加不可控了。</p>
<p>其实解决办法有很多的，或者说是预防措施，又或者说，其实是一个良好的编程习惯。比起直接在全局使用 <code>using namespace xxx</code> 好一点的做法是：<strong>在局部声明并且只声明需要的那个部分</strong>。比如如果在某个作用域内经常要使用 <code>std::cout</code>，<code>std::endl</code> 等，你可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1+1="</span> &lt;&lt; <span class="number">1</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1+2="</span> &lt;&lt; <span class="number">1</span> + <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1+3="</span> &lt;&lt; <span class="number">1</span> + <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然最好的还是在你要使用的东西前显示指定出它归属的名称空间，一来可以更清晰的知道它是来自哪里的库，二来这样写几乎放多久都不会有错。习惯成自然，养成了这个习惯，你就根本不会去想到有 <code>using namespace xxx</code> 这种东西了。</p>
<h3 id="二、Best-Practices"><a href="#二、Best-Practices" class="headerlink" title="二、Best Practices"></a>二、Best Practices</h3><p>在 <a href="https://www.amazon.com/dp/0321113586/?tag=stackoverfl08-20" target="_blank" rel="external">C++ Coding Standards</a> 里，有这样一段话：</p>
<blockquote>
<p><strong>Summary</strong><br>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.<br>Corollary: In header files, don’t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)<br><strong>Discussion</strong><br>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable.</p>
</blockquote>
<p>在 <a href="http://www.umich.edu/~eecs381/handouts/C++_Coding_Standards.pdf" target="_blank" rel="external">C++ Coding Standards for EECS 381</a>中 P32 有一段话：</p>
<blockquote>
<ul>
<li>Follow guidelines for namespace <code>using</code> statements.<ul>
<li>Namespace declarations and directives.<ul>
<li>No namespace using declarations or directives are allowed at the top level of a header file.<ul>
<li>OK if scoped within an inline or member function body or a class declaration.</li>
</ul>
</li>
<li>In <code>.cpp</code> files,<ul>
<li>Place using statements only after all <code>#includes</code>.</li>
<li>Prefer using declarations of specific Standard Library functions or classes to using namespace<br>directives.</li>
<li>Especially in this course, prefer using declarations or directives to explicitly qualifying Standard<br>Library names with <code>std::</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Namespaces" target="_blank" rel="external">Google C++ Style Guide</a> 中有一条：</p>
<blockquote>
<p>You may not use a using-directive to make all names from a namespace available.</p>
</blockquote>
<p>看了这几段，就胜过我千言万语了。</p>
<h3 id="三、关于匿名-namespace"><a href="#三、关于匿名-namespace" class="headerlink" title="三、关于匿名 namespace"></a>三、关于匿名 namespace</h3><p>关于 unnamed namespace，<a href="http://en.cppreference.com/w/cpp/language/namespace" target="_blank" rel="external">cppreference</a> 如是说到：</p>
<blockquote>
<p>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have internal linkage, which means that any name that is declared within an unnamed namespace has internal linkage. </p>
</blockquote>
<p>也就是说，现在，在匿名空间里的成员，具有内部链接，跟 static 没啥区别了。不过依然要注意，在同一层次中，可以有多个匿名空间，不过这些匿名空间会被整合成一个，所以不能像这样写，会报重定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然在不同空间内的匿名空间，当然就是不同的啦，下面这样就可以通过了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">namespace</span> n1</div><div class="line">&#123;</div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  foo();</div><div class="line">  n1::foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables" target="_blank" rel="external">Google C++ Style Guide</a> 中是这样说 unnamed namesapce 的：</p>
<blockquote>
<p>When definitions in a <code>.cc</code> file do not need to be referenced outside that file, place them in an unnamed namespace or declare them <code>static</code>. Do not use either of these constructs in <code>.h</code> files.<br><strong>Definition</strong><br>All declarations can be given internal linkage by placing them in unnamed namespaces, and functions and variables can be given internal linkage by declaring them <code>static</code>. This means that anything you’re declaring can’t be accessed from another file. If a different file declares something with the same name, then the two entities are completely independent.<br><strong>Decision</strong><br>Use of internal linkage in <code>.cc</code> files is encouraged for all code that does not need to be referenced elsewhere. Do not use internal linkage in <code>.h</code> files.</p>
</blockquote>
<p>他们鼓励在实现文件中，把那些不需要外部引用的东西放进匿名空间中。陈硕大大在他的 <a href="https://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf" target="_blank" rel="external">CppPractice</a> 中，第一个提到的就是慎用匿名空间。我觉得，对于他说的不利之处，现在来看，主要还是是第一点。因为匿名namespace里的东西是匿名的，所以万一以后有一天想引用它了，也说不准。其实还是用个具体名称，也不麻烦。对于那些实现细节，或者不希望暴露的，我还是喜欢扔进一个 <code>namespace details {}</code> 或者什么 <code>namespace impl {}</code> 里。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>总结就两点：</p>
<ul>
<li><strong>不要使用 <code>using namespace xxx</code>，使用 <code>xxx::yyy</code></strong></li>
<li><strong>使用具名 namespace</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6501505.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://www.alinshans.com/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://www.alinshans.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello, my world</title>
    <link href="http://www.alinshans.com/2017/05/17/p1705171/"/>
    <id>http://www.alinshans.com/2017/05/17/p1705171/</id>
    <published>2017-05-17T05:20:35.000Z</published>
    <updated>2017-05-17T05:56:50.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本在博客园和Github上有写一些随笔和笔记，不过博客园的编辑真的好难看，还不如 Markdown 格式的好看，所以就搭了一个新的博客，会陆续把一些以前写的搬到这里，以及新随笔和笔记都会在这里首发。</p>
<h2 id="Hello-my-world"><a href="#Hello-my-world" class="headerlink" title="Hello, my world"></a>Hello, my world</h2><p>大概每个人接触编程后，写的第一个程序都是 Hello world 。我们能轻松的用几行代码，就在一个黑框框或者更漂亮的界面上输出一个 Hello world，多亏了我们是站在了许多巨人的肩膀上。多希望有一天，我可以在自己创造的世界里，说一声 Hello, my world!</p>
<h2 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h2><p>以上所说的”自己创造的世界”，其实说的是自己创造自己喜欢的环境，可以是一个系统，可以是一种语言，可以是一个框架，甚至可以是一种语法。只要能让自己用得开心，想怎么改就怎么改，想怎么运行就怎么运行。当然，不可能从零开始，也不可能去重写所有的东西。这一个过程应该是自顶向下的，从能最直接接触到的东西开始，有不顺手的地方，那就给它包装，或者重写，直到自己顺手了，开心了为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本在博客园和Github上有写一些随笔和笔记，不过博客园的编辑真的好难看，还不如 Markdown 格式的好看，所以就搭了一个新的博客，会
    
    </summary>
    
      <category term="其他" scheme="http://www.alinshans.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
