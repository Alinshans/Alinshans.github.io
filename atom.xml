<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alinshans&#39;s world</title>
  <subtitle>Build a world of your own love</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://alinshans.github.io/"/>
  <updated>2017-05-29T15:54:23.192Z</updated>
  <id>http://alinshans.github.io/</id>
  
  <author>
    <name>刘俊延</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8086汇编：寄存器与寻址方式概述</title>
    <link href="http://alinshans.github.io/2017/05/29/p1705292/"/>
    <id>http://alinshans.github.io/2017/05/29/p1705292/</id>
    <published>2017-05-29T06:14:53.000Z</published>
    <updated>2017-05-29T15:54:23.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8086-计算机系统模型"><a href="#8086-计算机系统模型" class="headerlink" title="8086 计算机系统模型"></a>8086 计算机系统模型</h2><p><img src="http://i4.buimg.com/594413/a8c2fdc443111b52.gif" alt="8086 System Model"></p>
<p>通过系统总线，将计算机的各个部分链接在一起。<code>CPU</code> 则是这个体系的核心。</p>
<p><code>8086 CPU</code> 内部模型：</p>
<p><img src="http://i4.buimg.com/594413/1e35e99836b3d2c0.gif" alt="8086 CPU Model"></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><code>8086 CPU</code> 内部有14个可见的（程序员可操作）的寄存器，均为16位。分别为：AX, BX, CX, DX, SP, BP, SI, DI, IP, FLAG, CS, DS, SS, ES。这14个寄存器从用途上又分为三类：通用寄存器，控制寄存器和段寄存器。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>4个数据寄存器：AX, BX, CX, DX</p>
<ul>
<li>AX (Accumulator)：累加寄存器</li>
<li>BX (Base)：基址寄存器</li>
<li>CX (Count)：计数寄存器</li>
<li>DX (Data)：数据寄存器 </li>
</ul>
<p>这4个寄存器又可分为8个独立的8位寄存器：AH, BH, CH, DH, AL, BL, CL, DL。</p>
<p>2个指针寄存器：SP, BP</p>
<ul>
<li>SP (Stack Pointer)：堆栈指针寄存器</li>
<li>BP (Base Pointer)：基址指针寄存器</li>
</ul>
<p>2个变址寄存器：SI, DI</p>
<ul>
<li>SI (Source Index)：源变址寄存器</li>
<li>DI (Destination Index)：目的变址寄存器</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul>
<li>CS (Code Segment)：代码段寄存器</li>
<li>DS (Data Segment)：数据段寄存器</li>
<li>SS (Stack Segment)：堆栈段寄存器</li>
<li>ES (Extra Segment)：附加段寄存器</li>
</ul>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><ul>
<li>IP (Instruction Pointer)：指令指针寄存器</li>
<li>FLAG：标志寄存器</li>
</ul>
<h2 id="物理地址与有效地址"><a href="#物理地址与有效地址" class="headerlink" title="物理地址与有效地址"></a>物理地址与有效地址</h2><p><strong><code>物理地址(Physical Address)</code>就是CPU查找内存单元时的一个地址，它是唯一的</strong>。内存单元物理地址可由段址和段内的偏移量确定，<strong>内存单元在段内的偏移量就叫做<code>有效地址(Effective Address)</code></strong>。</p>
<p><code>8086 CPU</code>内部有20根地址线，其编码区间为：0000H~FFFFFH，所以，它的寻址能力（可直接访问的物理空间）为1M字节（2^20 bits）。但是<code>CPU</code>内部为16位的结构，如果用16位寄存器来访问内存的话，表现出来的寻址能力却只有64K。为了能用16位寄存器来有效地访问1M的存储空间，<code>CPU</code>内部采用了两个16位的地址来合成一个20位的物理地址。最终，<code>CPU</code>就采用下面这种方式来合成一个物理地址：</p>
<p><strong>物理地址 = 段地址 × 16 + 偏移地址</strong></p>
<p>这样的方式用汇编表现出来就是：</p>
<p><strong>段寄存器 : 偏移地址</strong></p>
<p>比如，<code>8086 CPU</code> 要访问物理地址为 <code>12000h</code>(十六进制)的内存单元，就可以把 <code>DS</code> 设为 <code>1000h</code>，把 <code>SI</code> 设为 <code>2000h</code>，然后通过 <code>DS:[SI]</code> 的方式表达，地址加法器就会按照上面的公式算出物理地址 = 1000h × 16 + 2000h = 12000h。</p>
<p>四个段寄存器就组成以下四种表达：</p>
<ul>
<li>CS : IP</li>
</ul>
<p>段寄存器<code>CS</code>指向存放程序的内存段，<code>IP</code>是用来存放下条待执行的指令在该段的偏移量，把它们合在一起可在该内存段内取到下次要执行的指令。</p>
<ul>
<li>DS : **</li>
</ul>
<p>段寄存器<code>DS</code>指向数据段，在存取操作数时，由<code>DS</code>和一个偏移量合成就可得到存储单元的物理地址。该偏移量可以是具体数值、符号地址和指针寄存器的值等之一，具体情况将由指令的寻址方式来决定。</p>
<ul>
<li>SS : SP</li>
</ul>
<p>段寄存器<code>SS</code>指向用于堆栈的内存段，<code>SP</code>是用来指向该堆栈的栈顶，把它们合在一起可访问栈顶单元。另外，当偏移量用到了指针寄存器<code>BP</code>，则其缺省的段寄存器也是<code>SS</code>，并且用<code>BP</code>可访问整个堆栈，不仅仅是只访问栈顶。</p>
<ul>
<li>ES : DI</li>
</ul>
<p>段寄存器<code>ES</code>指向附加数据段，也用于数据的保存，一般与<code>DS</code>用法类似，在进行串操作时，其目的地址的段寄存器规定为<code>ES</code>。</p>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>首先，要明确，什么是寻址方式。<strong>所谓寻址方式，就是讨论指令中操作数的来源问题</strong>。</p>
<p>根据操作数的不同来源来分类的话，寻址方式可以分为储存器方式和非储存器方式。下面着重讲 <code>8086/8088</code> 体系下的寻址方式。</p>
<p><code>8086 CPU</code> 有七种基本的寻址方式：</p>
<ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接寻址</li>
<li>寄存器间接寻址</li>
<li>寄存器相对寻址</li>
<li>基址变址寻址</li>
<li>相对基址变址寻址</li>
</ul>
<p>其中，前两种方式属于非储存器寻址方式，后五种属于储存器寻址方式。除了这些基本寻址方式，还有一些其它的寻址方式，如固定寻址、I/O端口寻址等，这些不会重点介绍。</p>
<p>为了总结方便，我<strong>费尽精力</strong>做了一个表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">指令特点</th>
<th style="text-align:center">举个栗子</th>
<th style="text-align:center">注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:center">用立即数给寄存器赋值</td>
<td style="text-align:center">mov ax, 1234h</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:center">源操作数为寄存器</td>
<td style="text-align:center">(1) mov num, ax<br>(2) mov ax, bx</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:center">括号内一个立即数</td>
<td style="text-align:center">(1) mov dx, [1000h]<br>(2) mov es:[1000h], dx</td>
<td style="text-align:center">使用<code>DS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:center">括号内一个基址或变址寄存器(<code>SI</code>,<code>DI</code>,<code>BX</code>,<code>BP</code>)</td>
<td style="text-align:center">(1) mov dx, [di]<br>(2) mov [bp], cx</td>
<td style="text-align:center">若有效地址在<code>SI</code>,<code>DI</code>和<code>BX</code>中，<br>则以<code>DS</code>作为缺省段寄存器；<br>若有效地址在<code>BP</code>中，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">寄存器相对寻址</td>
<td style="text-align:center">括号内一个基址或变址寄存器(<code>SI</code>,<code>DI</code>,<code>BX</code>,<code>BP</code>)+<br>一个立即数</td>
<td style="text-align:center">(1) mov ax, [bx+16]<br>(2) mov ax, 16[bx]<br>(3) mov es:[bx+5], al</td>
<td style="text-align:center">若<code>SI</code>,<code>DI</code>和<code>BX</code>作为有效地址的一部分，<br>则以<code>DS</code>作为缺省段寄存器；<br>若<code>BP</code>作为有效地址的一部分，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">基址变址寻址</td>
<td style="text-align:center">括号内一个基址寄存器(<code>BX</code>,<code>BP</code>)+<br>一个变址寄存器(<code>SI</code>,<code>DI</code>)</td>
<td style="text-align:center">(1) mov ax, [bx+si]<br>(2) mov ax, [si][bx]<br>(3) mov ds:[bp+si], al</td>
<td style="text-align:center">若<code>SI</code>,<code>DI</code>和<code>BX</code>作为有效地址的一部分，<br>则以<code>DS</code>作为缺省段寄存器；<br>若<code>BP</code>作为有效地址的一部分，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
<tr>
<td style="text-align:center">相对基址变址寻址</td>
<td style="text-align:center">括号内一个基址寄存器(<code>BX</code>,<code>BP</code>)+<br>一个变址寄存器(<code>SI</code>,<code>DI</code>)+<br>一个立即数</td>
<td style="text-align:center">(1) mov ax, [bx+di+10h]<br>(2) mov ax, 10h[bx+di]<br>(3) mov ax, 10h[bx][di]<br>(4) mov ax, 10h[di][bx]</td>
<td style="text-align:center">若<code>SI</code>,<code>DI</code>和<code>BX</code>作为有效地址的一部分，<br>则以<code>DS</code>作为缺省段寄存器；<br>若<code>BP</code>作为有效地址的一部分，<br>则以<code>SS</code>作为缺省段寄存器</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;8086-计算机系统模型&quot;&gt;&lt;a href=&quot;#8086-计算机系统模型&quot; class=&quot;headerlink&quot; title=&quot;8086 计算机系统模型&quot;&gt;&lt;/a&gt;8086 计算机系统模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i4.buimg.com/
    
    </summary>
    
      <category term="汇编" scheme="http://alinshans.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://alinshans.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编：前言</title>
    <link href="http://alinshans.github.io/2017/05/29/p1705291/"/>
    <id>http://alinshans.github.io/2017/05/29/p1705291/</id>
    <published>2017-05-29T04:23:13.000Z</published>
    <updated>2017-05-29T15:54:20.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习汇编"><a href="#为什么要学习汇编" class="headerlink" title="为什么要学习汇编"></a>为什么要学习汇编</h2><p>我觉得，对于一个合格的、资深的程序员来说，学习汇编和理解汇编是必不可少的。这里的汇编不特指某一平台的汇编，但其实核心内容都一样。</p>
<p>原因如下：</p>
<ul>
<li>学习汇编帮助你理解高级语言的运行</li>
<li>深度调试时的需要</li>
<li>编译器不总是对的</li>
</ul>
<p>尤其是 C/C++ 这类的编程语言，有很多坑，而一些书或者人只告诉你不能这样做，但是为什么不能这样做，只有汇编才能告诉你。</p>
<p>还有比如程序优化，只有通过反汇编，你才能确定，程序优化的结果。</p>
<p>以及一些编译器的坑，编译器也是人写的，不能100%正确，那你怎么确定是你的问题还是编译器的问题？只有汇编能救你。</p>
<h2 id="学习汇编的好处"><a href="#学习汇编的好处" class="headerlink" title="学习汇编的好处"></a>学习汇编的好处</h2><p><a href="https://www.zhihu.com/people/skogkatt/answers" target="_blank" rel="external">@Skogkatt</a> 在 <a href="https://www.zhihu.com/question/23088538/answer/23717201" target="_blank" rel="external">这个回答</a> 说：</p>
<blockquote>
<p>学汇编不是说一定要用这玩艺做多牛鼻的事情, 问题的关键在于, 学透了汇编会使你真正理解计算机<br><br>另外一方面, 如上面所说, 在工作中你迟早会在某个阴暗的角落遇到汇编. 不管你承认不承认, 现在的CPU没有直接跑高级语言的, 哪怕是虚拟机也都是类似汇编的指令集.<br><br>当遇到崩溃分析, 性能优化甚至编译器抽风等等的时候, 汇编是你最后一根救命稻草.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要学习汇编&quot;&gt;&lt;a href=&quot;#为什么要学习汇编&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习汇编&quot;&gt;&lt;/a&gt;为什么要学习汇编&lt;/h2&gt;&lt;p&gt;我觉得，对于一个合格的、资深的程序员来说，学习汇编和理解汇编是必不可少的。这里的汇编不特指某
    
    </summary>
    
      <category term="汇编" scheme="http://alinshans.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://alinshans.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（附录一）</title>
    <link href="http://alinshans.github.io/2017/05/28/p1705282/"/>
    <id>http://alinshans.github.io/2017/05/28/p1705282/</id>
    <published>2017-05-28T02:53:04.000Z</published>
    <updated>2017-05-29T15:54:55.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6639526.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6639526.html</a> ，修改而成。</em></p>
</blockquote>
<p>这篇内容呀，其实是接<a href="http://www.cnblogs.com/GodA/p/6569254.html" target="_blank" rel="external">上一篇</a>的结尾提出的一个小问题而写的，如果你还没有看过那么你可以先看一下。</p>
<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>在上一篇的最后，我提到一个问题：代码优化。并留下了一个小小的测试：无符号数和有符号数的性能比较。不知道有没有童鞋去实验一下呢？那我们一起来做一个简单的实验：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*unsigned */</span><span class="keyword">int</span> a = <span class="number">123456789</span>;</div><div class="line">  <span class="keyword">auto</span> t1 = <span class="built_in">std</span>::chrono::system_clock::now();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</div><div class="line">  &#123;</div><div class="line">    a += <span class="number">3</span>;</div><div class="line">    a -= <span class="number">5</span>;</div><div class="line">    a *= <span class="number">11</span>;</div><div class="line">    a /= <span class="number">7</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> t2 = <span class="built_in">std</span>::chrono::system_clock::now();</div><div class="line">  <span class="keyword">auto</span> runtime = <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::nanoseconds&gt;(t2 - t1);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; runtime.count() &lt;&lt; <span class="string">"ns"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上述代码在 VS 的 <code>Debug</code> 模式下运行，稳定后运行时间在 210000ns 左右，然后把注释去掉，再次运行，稳定后运行时间也是 210000ns 左右。在我在电脑上，计算有符号类型和无符号类型几乎是没有差别的，我相信在绝大多数的电脑上也是相同的结果。</p>
<p>类似的问题还有：浮点数的计算比整型数慢？对于这个问题，可以看一下这个问题：<a href="https://www.zhihu.com/question/26494062" target="_blank" rel="external">https://www.zhihu.com/question/26494062</a> 。里面提供大量实验数据供参考。</p>
<p>无论如何，实际情况下就是，在当代，计算无符号数和有符号数的效率，甚至是计算浮点数和整数的效率，差异并不大。</p>
<p>我想说明什么呢？首先我要声明：我不是反对代码优化。而是对于有很多流传广泛的所谓的优化技巧，我觉得我们应该应该抱着学习探索的心态，而不是一味地追求一些没有什么意义的东西。有些优化，确实很精妙。但很多所谓的技巧，看起来的意思就是：做编译器的那群人都是傻逼。想优化我们的程序，这是正常的、应该的想法，但我们应该用科学的方法，而不是听了一些奇淫技巧，却不知道实际发生了什么。</p>
<p>其实很简单，探究性能瓶颈靠 <code>profiling</code>，探究代码背后的不为人知的故事看 <code>assembly</code>。我们先讲后面一个。</p>
<h2 id="利用-assembly-探究代码"><a href="#利用-assembly-探究代码" class="headerlink" title="利用 assembly 探究代码"></a>利用 <code>assembly</code> 探究代码</h2><p>怎么得到反汇编代码，我在 <a href="https://alinshans.github.io/2017/05/23/p1705231/">这一篇</a> 当中有提到。比如我们研究有符号数和无符号数，先写一个程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*unsigned */</span><span class="keyword">int</span> a = <span class="number">123456789</span>;</div><div class="line">  a = a / <span class="number">13</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在 VS 下查看反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*unsigned */<span class="keyword">int</span> a = <span class="number">123456789</span><span class="comment">;</span></div><div class="line">00B4104E  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="number">75BCD15h</span>  </div><div class="line">  a = a / <span class="number">13</span><span class="comment">;</span></div><div class="line">00B41055  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [a]  </div><div class="line">00B41058  <span class="keyword">cdq</span>  </div><div class="line">00B41059  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">0Dh</span>  </div><div class="line">00B4105E  <span class="keyword">idiv</span>        <span class="built_in">eax</span>,<span class="built_in">ecx</span>  </div><div class="line">00B41060  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="built_in">eax</span></div></pre></td></tr></table></figure></p>
<p>把注释去掉再看：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">unsigned <span class="keyword">int</span> a = <span class="number">123456789</span><span class="comment">;</span></div><div class="line">00C3104E  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="number">75BCD15h</span>  </div><div class="line">  a = a / <span class="number">13</span><span class="comment">;</span></div><div class="line">00C31055  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [a]  </div><div class="line">00C31058  <span class="keyword">xor</span>         <span class="built_in">edx</span>,<span class="built_in">edx</span>  </div><div class="line">00C3105A  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">0Dh</span>  </div><div class="line">00C3105F  <span class="keyword">div</span>         <span class="built_in">eax</span>,<span class="built_in">ecx</span>  </div><div class="line">00C31061  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [a],<span class="built_in">eax</span></div></pre></td></tr></table></figure></p>
<p>几乎是一模一样的，最大的差别就是有符号数使用 idiv指令（带符号除法），无符号数使用 div指令（不带符号除法），而这两种指令，CPU 周期都是一样的。<a href="http://www.agner.org/optimize/instruction_tables.pdf" target="_blank" rel="external">http://www.agner.org/optimize/instruction_tables.pdf</a></p>
<p>当然我不是说不用无符号数，而是说我们用什么要看场合，而不是你觉得用了性能更好，除非是被大众认可的或者你经过严谨的测试的。像对于某些书籍或者什么地方说，只要确定范围不为负数的，就用无符号类型，我是不认可的。如果你讲范围，那如果一个有符号类型不够用，那么通常它对应的无符号类型(相同的 bits)也不够用。比如你 <code>std::int32_t</code> 不够用，就应该用 <code>std::int64_t</code>，如果还不够，考虑写个 <a href="https://github.com/Alinshans/redbud/blob/master/redbud/bignumber.h" target="_blank" rel="external">BigInteger类</a> 吧。不过对于无符号和有符号类型，它们之间的性能在当代确实是几乎没有什么差别。那具体什么场合用什么呢？这个也不一定，比如一般来说：</p>
<ul>
<li>对于位储存、位运算、模运算等，使用无符号类型</li>
<li>对于一般运算使用有符号类型</li>
</ul>
<p>这一篇的目的，当然不只是谈有符号数和无符号数，而是想借题引出一些我的看法：</p>
<ul>
<li>过早的优化是万恶之源</li>
<li>不要试图帮编译器优化</li>
<li>优化时不要去猜测，想当然得去优化自己“觉得”性能不好的地方</li>
</ul>
<p>我们一点一点讲。</p>
<p>对于一个需求，我们应该先完成功能，若性能达不到要求之后，在确定瓶颈之后再去优化。过早优化，不仅让代码不直接，还容易出 bug，还可能对性能几乎没有影响。而且，我们优化时，应该关注大方向，确定大方向是正确的。比如写一个算法，我们首先应该确保 <code>Big-O</code> 的时间复杂度能达标，可以用 <code>O(n)</code> 的就不用 <code>O(nlogn)</code>，可以用 <code>O(nlogn)</code> 的就不用 <code>O(n²)</code>，而不是先在那里扣 <code>i++</code> 还是 <code>++i</code>。另外，不要想着去帮编译器优化，因为编译器是一堆比你强不知道多少的人写出来的，而对于一般人，想着去帮编译器优化，大部分是无效的，甚至是错的。比如有人学了一点点的 <code>std::move</code>，就老是想着 move move move 去提高性能，举个栗子，容易写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">create</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">auto</span> object = <span class="keyword">new</span> T();</div><div class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(object);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>确实运行不会错，但是，代码背后做的事情不一定就跟你想的一样，往往跟你想象的还不一样。有些情况编译器可以采用更好的办法，结果因为你那么一搞，迫不得已只能采用次一点的办法。可以看看 <a href="https://www.zhihu.com/question/57048704" target="_blank" rel="external">这个问题</a>，就不赘述了。</p>
<p>还有比如说用异或来交换两个变量，有人会想，用位运算，不仅不需要创建临时变量，而且位运算一般不是更快嘛！对于这个问题，陈硕大大早有讲到，在 <a href="https://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf" target="_blank" rel="external">https://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf</a> 的第 9 章。可以去看一下。</p>
<p>如果你已经看了上面的链接，那么你也就知道了，你（几乎）不会知道编译器做了什么，编译器可以做的优化超出你的想象（不过有的时候人能明显看出来的优化编译器却做不到，但影响不大），在我的 <a href="https://alinshans.github.io/2017/05/23/p1705231/">系列文章（二）</a> 中也有强调了，不要试图帮助编译器去优化。若你想探究一小段代码背后不为人知的故事，就去看看反汇编！</p>
<h2 id="利用-profiling-探究瓶颈"><a href="#利用-profiling-探究瓶颈" class="headerlink" title="利用 profiling 探究瓶颈"></a>利用 <code>profiling</code> 探究瓶颈</h2><p>关于这个问题，我想贴上一个链接，是 <a href="https://www.zhihu.com/people/lan-se-52-30/answers" target="_blank" rel="external">蓝色大大</a> 的一个回答：<a href="https://www.zhihu.com/question/56727144/answer/150555866" target="_blank" rel="external">https://www.zhihu.com/question/56727144/answer/150555866</a>。有非常详细清晰的介绍。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后我希望我放的链接都有认真看呀！为什么我贴那么多链接呢？因为我说的话没有权威没人信啊！但大牛们说的总有参考价值了吧！</p>
<p>暂时先写那么多，才学疏浅，如有不当地方还请海涵，感谢指点！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6639526.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://alinshans.github.io/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://alinshans.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑（三）</title>
    <link href="http://alinshans.github.io/2017/05/28/p1705281/"/>
    <id>http://alinshans.github.io/2017/05/28/p1705281/</id>
    <published>2017-05-28T02:01:33.000Z</published>
    <updated>2017-05-29T15:55:05.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6569254.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6569254.html</a> ，修改而成。</em></p>
</blockquote>
<p>这一篇会讲一个很小的点，但又经常容易犯错 ¯_(ツ)_/¯ ———— <strong><code>unsigned type</code></strong>。</p>
<h2 id="一、unsigned-type-的坑"><a href="#一、unsigned-type-的坑" class="headerlink" title="一、unsigned type 的坑"></a>一、unsigned type 的坑</h2><p>看到这篇的开头，你可能就会想，<code>unsigned type</code> 能有什么坑的呀！那我们就直接了当一些吧！</p>
<h3 id="1-小心可能陷入的死循环"><a href="#1-小心可能陷入的死循环" class="headerlink" title="1. 小心可能陷入的死循环"></a>1. 小心可能陷入的死循环</h3><p>其实单独的 <code>unsigned type</code> 你还是比较容易想明白的，怕的就是它跟一些其它东西搭配（比如 <code>auto</code>），而你又忽略了那就是 <code>unsigned type</code> 的时候，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> sz[] = <span class="string">"Hello world!"</span>;</div><div class="line">  <span class="comment">// 倒序输出字符串</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">std</span>::<span class="built_in">strlen</span>(sz) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sz[i];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于上述的代码，会有什么问题吗？当然啦，有些经验的人还是一眼就能看出来的，还有一些人需要多看两眼才能看出来。</p>
<p>问题就在于 <code>std::strlen</code> 的返回值类型是 <code>std::size_t</code> ，这是一个 <code>unsigned type</code>，而一个 <code>unsigned type</code> 的数值永远大于等于 0，是的没错，你很快就反应过来，死循环了。当然这个例子比较简单，而且如果你用 VS 这种有 <code>intelliSense</code> 的 IDE，你敲出函数，或者鼠标移到函数名字上，就能看到函数的声明。那万一不是用这种 IDE 的呢？又或者，一些你不认识的函数，而且类型也被 <code>typedef</code> 到你认不出来了，你又如何分辨呢？虽然这是简单的例子，但确实存在这种风险。</p>
<h3 id="2-小心可能的访问越界"><a href="#2-小心可能的访问越界" class="headerlink" title="2. 小心可能的访问越界"></a>2. 小心可能的访问越界</h3><p>其实上面的例子也是属于访问越界，但 C++ 的数组兼容 C，而 C 的数组是不作边界检查的，所以实际上，上述代码运行起来不会崩溃，甚至还不一定会出错。为什么说不一定呢，因为 <code>sz[-1]</code> 的内容是不知道的…所以输出也有可能让你撞对了，但是！这个<strong>代码一定是错误的</strong>。所以我会推荐使用 C++ 的容器，对于日常使用，已经绰绰有余了。C++ 的容器，在 <code>Debug</code> 模式下，是会做边界检查的。比如用 VS，在 <code>Debug</code> 下，容器访问越界了，它会有弹出一个 <code>MessageBox</code> 显示 <code>xxx subscript out of range</code> 之类的信息。</p>
<p>好了回归正题，使用容器时，要是一不小心，写出了类似代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就会导致了访问越界了，原因也是 <code>size()</code> 的返回类型是 <code>std::size_t</code> 。</p>
<p>之前我写一个 <a href="https://github.com/Alinshans/redbud/blob/master/redbud/bignumber.h" target="_blank" rel="external">BigInteger</a> 类的时候，就有很多用到了这样的倒序输出的地方。一开始没注意，也是出现了访问越界的错误，后来看到 <code>vector subscript out of range</code> 才反应过来。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>unsigned type</code> 的坑其实也不算很深，主要在于 0 这个点，要注意以下。解决的方案（至少）有以下几种：</p>
<h3 id="1-显示指定可容纳范围内的-signed-type"><a href="#1-显示指定可容纳范围内的-signed-type" class="headerlink" title="1. 显示指定可容纳范围内的 signed type"></a>1. 显示指定可容纳范围内的 <code>signed type</code></h3><p>如果你知道你数据的确切范围，比如不会超过 100w，那么就可以用一个能够放得下 100w 的一个 <code>signed type</code> 去指定它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div></pre></td></tr></table></figure></p>
<h3 id="2-手动做边界检查"><a href="#2-手动做边界检查" class="headerlink" title="2. 手动做边界检查"></a>2. 手动做边界检查</h3><p>如果你不能确定大小，而且不确定 signed type 能否容纳下那个 unsigned type 的全部范围，那就自己在循环的周围做一个边界检查：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (v.size() != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-把边界检查移到循环外部"><a href="#3-把边界检查移到循环外部" class="headerlink" title="3. 把边界检查移到循环外部"></a>3. 把边界检查移到循环外部</h3><p>其实是第2种方法的变形，如果你唯恐在循环内检查损失了很多性能，那么就可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (v.size() != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-使用-C-迭代器"><a href="#4-使用-C-迭代器" class="headerlink" title="4. 使用 C++ 迭代器"></a>4. 使用 C++ 迭代器</h3><p>既然用了 C++ 的容器，那么更好的写法当然是这样啦：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.rbegin(); i != v.rend(); ++i)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就不需要去考虑下标范围啦，什么检查啦，多方便！如果想写出更泛型，更有 C++ Style 的代码，还可以这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::rbegin(v), <span class="built_in">std</span>::rend(v), [&amp;](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>; &#125;);</div></pre></td></tr></table></figure></p>
<p>最终选择什么样的方式还是看实际情况跟个人爱好咯！</p>
<h2 id="三、其它杂谈"><a href="#三、其它杂谈" class="headerlink" title="三、其它杂谈"></a>三、其它杂谈</h2><p>我在网上看到不少关于什么“代码优化技巧”等等文章，即使是最近出的，还是这样写，也不知道是不是到处抄的。比如我看到<a href="http://www.codeceo.com/article/c-high-performance-coding.html" target="_blank" rel="external">其中一篇</a>就说到：</p>
<blockquote>
<p>有些处理器处理无符号unsigned 整形数的效率远远高于有符号signed整形数</p>
</blockquote>
<p>正确与否我就先不说了，错别字我也不去说了。留给读者先自己实验一下，我会在下一篇中用一篇来讨论一下这类问题。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>小标题即总结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6569254.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://alinshans.github.io/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://alinshans.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑(二)</title>
    <link href="http://alinshans.github.io/2017/05/23/p1705231/"/>
    <id>http://alinshans.github.io/2017/05/23/p1705231/</id>
    <published>2017-05-23T02:31:42.000Z</published>
    <updated>2017-05-28T03:37:34.609Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6554591.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6554591.html</a> ，修改而成。</em></p>
</blockquote>
<p>这一篇将会聊聊C++中一个极具迷惑性的关键字 ———— <strong>inline</strong>。<br>虽然只是一个小小的关键字，但要是没有真正了解它，也是很容易踩坑的。</p>
<h3 id="一、什么是-inline"><a href="#一、什么是-inline" class="headerlink" title="一、什么是 inline"></a>一、什么是 inline</h3><p>或许你对它有那么一点点熟悉，但是又说不清。它的中文翻译为“内联”。它经常跟一个东西共同出现，称为“内联函数(<a href="https://msdn.microsoft.com/en-us/library/bw1hbe6y.aspx" target="_blank" rel="external">inline function</a>)”。正是这样的翻译，对新手产生了太多的误会。那么什么是 inline 呢？现在暂时不做解答。接下来你可能会经常用到 <a href="http://en.cppreference.com/w/cpp/language/inline" target="_blank" rel="external">cppreference</a>，所以你可以先点开放到一旁，然后我们进入正题。</p>
<h3 id="二、inline-之初印象"><a href="#二、inline-之初印象" class="headerlink" title="二、inline 之初印象"></a>二、inline 之初印象</h3><p>上网搜一下，<a href="http://cn.bing.com/search?q=c%2b%2b+inline%e7%9a%84%e4%bd%9c%e7%94%a8&amp;qs=AS&amp;pq=c%2b%2b+inline+&amp;sk=AS1&amp;sc=8-11&amp;cvid=5A4D624B9B484EC384CAA3BBA9FC70A6&amp;FORM=QBRE&amp;sp=2" target="_blank" rel="external">C++ inline 的作用</a>，你看到的都是什么？都是说 inline 函数可以自动把函数展开呀，可以减小函数调用的开销呀……还会好心提醒你，太大的函数不宜用 inline 呀！会导致代码膨胀呀！只有那些短小精悍的、经常调用的函数使用 inline 才能看到非常明显的效果呀…………我在 N 年前，也是这么傻傻的，所以看到短函数就想加 inline，唯恐性能变差。于是，在印象里，<code>inline</code> 就跟<code>优化</code>挂上钩了。</p>
<h3 id="三、inline-之初体验"><a href="#三、inline-之初体验" class="headerlink" title="三、inline 之初体验"></a>三、inline 之初体验</h3><p>我们先从简单的例子开始，新建一个 <code>main.cpp</code> 源文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们编译运行，好，通过了。看到这个函数手痒了是吧，好我们给它加上 <code>inline</code>，再次编译运行，也通过了。到这里还没有问题，具体它的优化我们暂时不去分析。我们要养成一个工程习惯嘛！这是个简单的例子，但实际中我们写的代码可能很多，可能有很多很多个类似于 <code>max</code> 这样的函数，于是我们就想着把他们区分开，于是我们又创建了一个 <code>a.h</code> 头文件，把 <code>max</code> 扔进去，我们还想着接口与实现分离，于是我们创建一个 <code>a.cpp</code> 源文件来实现函数的定义，文件结构变成了这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.h</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们运行一遍，没有问题，然后我们试着给 <code>max</code> 函数加上 <code>inline</code>，你知道，<strong>Ⅰ.<code>inline</code> 要跟函数的定义放在一块</strong>，所以我们就要在 <code>a.cpp</code> 给它加上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>我们再次编译运行，WTF！！怎么报错了！！不就加了个 <code>inline</code> 吗？！！ 冷静了一会，我们看看报错信息，如果你用的是 VS，那么你大概会看到这样的提示：</p>
<pre><code>1&gt;main.obj : error LNK2019: 无法解析的外部符号 &quot;int __cdecl max(int,int)&quot; (?max@@YAHHH@Z)，该符号在函数 _main 中被引用
1&gt;C:\Users\Alinshans\documents\visual studio 2017\Projects\test\Debug\test.exe : fatal error LNK1120: 1 个无法解析的外部命令
</code></pre><p>是不是感觉有点熟悉？似曾相识？如果你用的是 G++ 去编译，那么大概会得到这样的提示：</p>
<pre><code>main.cpp:(.text+0x13): undefined reference to `max(int, int)&apos;
</code></pre><p>要是你对C/C++编译的过程有一点点了解的话，我们继续尝试用 G++ 去分别运行下面的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> g++ -c main.cpp</div><div class="line"><span class="meta">$</span> g++ main.o -o a.out</div></pre></td></tr></table></figure></p>
<p>你就会发现，运行第一条命令（编译）时，是没有错的，运行第二条命令（链接）时，就报错了。<br><img src="http://i4.buimg.com/594413/c1c976d3dff1de9f.png" alt="Markdown"><br>这里说明一下，大多数的建置环境都是在编译过程进行 inlining（为了替换函数调用，编译器需要知道函数的实体长什么样，这就解释了 Ⅰ），某些可以在连接期完成，少数的可以在运行期完成。我们只考虑绝大部分情况：inlining 在大多数C++程序中是编译期行为。<br>好了，我们讲回来，为什么会出现这个链接错误呢？注意到刚刚打开的网页 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">这里的第二、三条</a> ：</p>
<blockquote>
<p>2) The definition of an inline function or variable (since C++17) must be present in the translation unit where it is accessed (not necessarily before the point of access).<br>3) An inline function or variable (since C++17) with external linkage (e.g. not declared <code>static</code>) has the following additional properties:<br>  1) It must be declared <code>inline</code> in every translation unit.<br>  2) It has the same address in every translation unit.</p>
</blockquote>
<p>这里提到了 <code>external linkage</code>，若想详细了解可以看 <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Linkage" target="_blank" rel="external">这里</a>。嫌太长不看的你只需要知道我们定义的 <code>max</code> 函数，具有 <code>external linkage</code>，那么它就要满足：</p>
<ul>
<li>在你需要引用它的编译单元可见</li>
<li>在每个编译单元都要声明为 <code>inline</code></li>
</ul>
<p>用人话讲就是，你要把这个 inline function 的定义放到每一个你需要引用的 <code>.cpp(.cc/.cxx等)</code> 源文件。也就是说你要把 <code>main.cpp</code> 写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，这下就没问题了，可以编译通过了。但是，这就需要我们把在源文件内声明为 <code>inline</code> 的函数，复制到每一个需要引用的单元，这样可不好看。所以，一般情况下，<strong>Ⅱ. <code>inline</code> 函数的定义放在头文件中，而不放在源文件中</strong>。</p>
<h3 id="四、inline-之再体验"><a href="#四、inline-之再体验" class="headerlink" title="四、inline 之再体验"></a>四、inline 之再体验</h3><p>经过刚刚的了解，我们就试一试在头文件中给函数加上或不加上 <code>inline</code> 的区别吧！我们在 <code>a.h</code> 中新增一个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.h</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，<code>a.cpp</code> 文件依然没有变：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>main.cpp</code> 中引用这个 <code>min</code> 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="keyword">int</span> res2 = min(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">" "</span> &lt;&lt; res2 &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好我们编译运行一下，很好通过了，没有什么问题。我们试试看去掉 <code>inline</code> 会有什么区别吧！<br>WTF!!!怎么又报错了！？？这次又是什么鬼！？这一次，VS的提示是：</p>
<pre><code>1&gt;main.obj : error LNK2005: &quot;int __cdecl min(int,int)&quot; (?min@@YAHHH@Z) 已经在 a.obj 中定义
1&gt;C:\Users\Alinshans\documents\visual studio 2017\Projects\test\Debug\test.exe : fatal error LNK1169: 找到一个或多个多重定义的符号
</code></pre><p>是不是感觉也似曾相识？（<em>注意，若使用G++编译运行时，可能没有报错，并且正常运行，但这不是值得侥幸的</em>）我们稍微思考一下就能想明白：在 <code>a.h</code> 中定义了 <code>min</code> 这个函数，而在 <code>main.cpp</code> 中，又 <code>#include</code> 了 <code>a.h</code> 这个文件，其中 <code>a.cpp</code> 这个编译单元在生成 <code>a.obj</code> 时会为 <code>min</code> 生成一个实体，而 <code>main.cpp</code> 又为 <code>min</code> 生成了一个实体，所以就会出现重定义。<br>那为什么我们使用 <code>inline</code> 时，就不会有这个错误呢？</p>
<h3 id="五、什么时候应该使用-inline"><a href="#五、什么时候应该使用-inline" class="headerlink" title="五、什么时候应该使用 inline"></a>五、什么时候应该使用 inline</h3><p>我们还是翻到刚刚的链接，看到 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">第一条</a>：</p>
<blockquote>
<p>1) There may be more than one definition of an inline function or variable (since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables (since C++17)) all definitions are identical. For example, an inline function or an inline variable (since C++17) may be defined in a header file that is #include’d in multiple source files.</p>
</blockquote>
<p>用人话说就是声明为 <code>inline</code> 的函数可以在多个编译单元中重复定义，且只会为它们生成一份实体。<br>刚刚我们在 <code>a.h</code> 内定义的函数，就必须要加上 <code>inline</code> 声明（或者<code>static</code>也是可以的，这里不展开了）。<br>所以，<strong>Ⅲ. 当且仅当函数定义在头文件且有可能被多个源文件包含时，使用 <code>inline</code></strong> 。</p>
<h3 id="六、inline-与类成员函数、模板"><a href="#六、inline-与类成员函数、模板" class="headerlink" title="六、inline 与类成员函数、模板"></a>六、inline 与类成员函数、模板</h3><p>这个部分应该也是很让新手纠结的。因为一个类，可能会有很多 getter/setter 之类的短小的函数，于是就会去纠结要不要加 <code>inline</code>。同时类的成员函数定义的位置，也有以下三种（假设类的声明在 <code>a.h</code>，定义在 <code>a.cpp</code>）：</p>
<ul>
<li>在头文件中，定义在类中</li>
<li>在头文件中，定义在类外</li>
<li>在源文件中</li>
</ul>
<p>我们一个一个来谈谈。首先是定义在类中的，需不需要加 <code>inline</code> 呢？还是看到刚刚的页面，<a href="http://en.cppreference.com/w/cpp/language/inline" target="_blank" rel="external">最上面这里</a>：</p>
<blockquote>
<p>A function defined entirely inside a class/struct/union definition, whether it’s a member function or a non-member <code>friend</code> function, is implicitly an inline function. </p>
</blockquote>
<p>定义在类中的函数，是隐式 <code>inline</code> 的，所以不需要你加 <code>inline</code>，而且，<a href="http://llvm.org/docs/CodingStandards.html#don-t-use-inline-when-defining-a-function-in-a-class-definition" target="_blank" rel="external">LLVM CodingStandards</a> 也是这样提出的：</p>
<blockquote>
<p>Don’t use inline when defining a function in a class definition</p>
</blockquote>
<p>我们再讲讲定义在源文件中的，要是你认真看过本文，你就会知道，前面说了，不要把 inline 函数定义在源文件中，所以如果你类成员函数定义在了源文件中，也不需要加 <code>inline</code>。<br>剩下一个，其实我想不到什么理由，可以让成员函数既不定义在类内，也不定义在源文件中（<strong>模板类成员函数/类模板成员函数除外</strong>）。如果成员函数比较短小，那么你就可以直接定义在类内，否则可以定义在源文件中。而要是非得要定义在头文件且在类外，那就必须要声明为 <code>inline</code>，否则也会有一个重定义的错误。但为什么不直接定义在类中呢？<br>所以综上所述，<strong>Ⅳ. 不要把 <code>inline</code>用于类成员函数</strong>。</p>
<p>然后再讲模板，包括了函数模板、类模板成员函数和模板类成员函数。有点晕是吧，反正就是有带模板的函数。这些函数具有 <code>inline</code> 语义，是自带 <code>inline</code> 属性的。也就是说，你把刚刚的那个 <code>a.h</code> 文件里的 <code>min</code> 函数改成模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不需要加上 <code>inline</code>，也是可以正常运行的。所以，<strong>Ⅴ. 模板不需要声明为 <code>inline</code>，也具有 <code>inline</code> 的语义</strong>。</p>
<h3 id="七、inline-与优化"><a href="#七、inline-与优化" class="headerlink" title="七、inline 与优化"></a>七、inline 与优化</h3><p>刚刚说了 <code>inline</code> 的用法，现在终于到了要摧毁印象的时候了。我们就先用 <code>main.cpp</code> 来测试：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，<code>max</code> 函数是声明为 <code>inline</code> 的，我们可以看反汇编代码，来看看 <code>max</code> 是否有调用。使用 GCC，可以分别运行以下三条命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> g++ -E main.cpp -o main.i</div><div class="line"><span class="meta">$</span> g++ -S main.i -o main.s</div><div class="line"><span class="meta">$</span> g++ -O2 -S main.i -o main2.s</div></pre></td></tr></table></figure></p>
<p>然后 <code>main.s</code> 和 <code>main2.s</code> 就是分别未使用优化和 使用了<code>O2</code>优化后的反汇编代码。<br>在 VS 下看反汇编就非常简单了，随便设置一个断点，然后点<code>调试</code>-&gt;<code>开始调试</code>，等程序运行后，点<code>调试</code>-&gt;<code>窗口</code>-&gt;<code>反汇编</code>，就可以看到反汇编代码了。因为 VS 的反汇编的代码比较清晰好看，所以就以 VS 中的反汇编为例。<br>我们先在 <code>Debug</code> 模式下，查看反汇编代码（主要部分）：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></div><div class="line">002218AE  <span class="keyword">push</span>        <span class="number">2</span>  </div><div class="line">002218B0  <span class="keyword">push</span>        <span class="number">1</span>  </div><div class="line">002218B2  <span class="keyword">call</span>        max (<span class="number">02212BCh</span>)  </div><div class="line">002218B7  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span>  </div><div class="line">002218BA  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [res],<span class="built_in">eax</span>  </div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, res)<span class="comment">;</span></div><div class="line">002218BD  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [res]  </div><div class="line">002218C0  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">002218C1  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0227B30h</span>)  </div><div class="line">002218C6  <span class="keyword">call</span>        _printf (<span class="number">022132Fh</span>)  </div><div class="line">002218CB  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>我们可以看到，是有调用 <code>max</code> 函数的。我们再切换到 <code>Release</code> 模式，查看反汇编代码：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, res)<span class="comment">;</span></div><div class="line"><span class="number">00131040</span>  <span class="keyword">push</span>        <span class="number">2</span>  </div><div class="line"><span class="number">00131042</span>  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">01320F8h</span>)  </div><div class="line">  <span class="keyword">int</span> res = max(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">;</span></div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, res)<span class="comment">;</span></div><div class="line"><span class="number">00131047</span>  <span class="keyword">call</span>        printf (<span class="number">0131010h</span>)  </div><div class="line">0013104C  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>是的，<code>max</code> 函数的调用已经不见了，不过你认为这是拜你加上的 <code>inline</code> 所赐的吗？我们去掉 <code>inline</code> ，再重复一遍刚刚的过程，你会发现，结果是一模一样的。<br>你没有死心，说，这个函数太简单了，我是编译器我也能看得出来怎么优化，要是函数复杂一点，比如有循环、递归什么的，编译器就不会自动优化了！<br>那好吧，我们把 <code>main.cpp</code> 改成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</div><div class="line">  &#123;</div><div class="line">    x += j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, test(<span class="number">100</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>Debug</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">010118AE  <span class="keyword">push</span>        <span class="number">64h</span>  </div><div class="line">010118B0  <span class="keyword">call</span>        <span class="keyword">test</span> (<span class="number">0101136Bh</span>)  </div><div class="line">010118B5  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">4</span>  </div><div class="line">010118B8  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">010118B9  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">01017B30h</span>)  </div><div class="line">010118BE  <span class="keyword">call</span>        _printf (<span class="number">0101132Fh</span>)  </div><div class="line">010118C3  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>在 <code>Release</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00F31042  <span class="keyword">xor</span>         <span class="built_in">ecx</span>,<span class="built_in">ecx</span>  </div><div class="line">00F31044  <span class="keyword">xor</span>         <span class="built_in">eax</span>,<span class="built_in">eax</span>  </div><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00F31046  <span class="keyword">xor</span>         <span class="built_in">edx</span>,<span class="built_in">edx</span>  </div><div class="line">00F31048  <span class="keyword">xor</span>         <span class="built_in">esi</span>,<span class="built_in">esi</span>  </div><div class="line">00F3104A  <span class="keyword">xor</span>         <span class="built_in">edi</span>,<span class="built_in">edi</span>  </div><div class="line">00F3104C  <span class="keyword">nop</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </div><div class="line">00F31050  <span class="keyword">inc</span>         <span class="built_in">edi</span>  </div><div class="line">00F31051  <span class="keyword">add</span>         <span class="built_in">esi</span>,<span class="number">2</span>  </div><div class="line">00F31054  <span class="keyword">add</span>         <span class="built_in">edx</span>,<span class="number">3</span>  </div><div class="line">00F31057  <span class="keyword">add</span>         <span class="built_in">ecx</span>,<span class="built_in">eax</span>  </div><div class="line">00F31059  <span class="keyword">add</span>         <span class="built_in">edi</span>,<span class="built_in">eax</span>  </div><div class="line">00F3105B  <span class="keyword">add</span>         <span class="built_in">esi</span>,<span class="built_in">eax</span>  </div><div class="line">00F3105D  <span class="keyword">add</span>         <span class="built_in">edx</span>,<span class="built_in">eax</span>  </div><div class="line">00F3105F  <span class="keyword">add</span>         <span class="built_in">eax</span>,<span class="number">4</span>  </div><div class="line">00F31062  <span class="keyword">cmp</span>         <span class="built_in">eax</span>,<span class="number">64h</span>  </div><div class="line">00F31065  <span class="keyword">jl</span>          main+<span class="number">10h</span> (<span class="number">0F31050h</span>)  </div><div class="line">00F31067  <span class="keyword">lea</span>         <span class="built_in">eax</span>,[<span class="built_in">edx</span>+<span class="built_in">esi</span>]  </div><div class="line">00F3106A  <span class="keyword">add</span>         <span class="built_in">eax</span>,<span class="built_in">edi</span>  </div><div class="line">00F3106C  <span class="keyword">add</span>         <span class="built_in">ecx</span>,<span class="built_in">eax</span>  </div><div class="line">00F3106E  <span class="keyword">push</span>        <span class="built_in">ecx</span>  </div><div class="line">00F3106F  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0F320F8h</span>)  </div><div class="line">00F31074  <span class="keyword">call</span>        printf (<span class="number">0F31010h</span>)  </div><div class="line">00F31079  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>喔，不要看它这么长，其实它是直接算出结果的了，所以已经没有 <code>test</code> 的调用了。这次看用G++生成的反汇编会更清晰一些：<br>不开优化：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line"><span class="symbol">.LFB1022:</span></div><div class="line"><span class="meta">	.cfi_startproc</span></div><div class="line">	pushq	%rbp</div><div class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></div><div class="line"><span class="meta">	.cfi_offset</span> <span class="number">6</span>, -<span class="number">16</span></div><div class="line">	<span class="keyword">movq</span>	%rsp, %rbp</div><div class="line"><span class="meta">	.cfi_def_cfa_register</span> <span class="number">6</span></div><div class="line">	movl	<span class="number">$100</span>, %edi</div><div class="line">	<span class="keyword">call</span>	_Z4testi</div><div class="line">	movl	%eax, %esi</div><div class="line">	movl	$.LC0, %edi</div><div class="line">	movl	<span class="number">$0</span>, %eax</div><div class="line">	<span class="keyword">call</span>	printf</div><div class="line">	movl	<span class="number">$0</span>, %eax</div><div class="line">	popq	%rbp</div><div class="line"><span class="meta">	.cfi_def_cfa</span> <span class="number">7</span>, <span class="number">8</span></div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>开O2优化：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line"><span class="symbol">.LFB1022:</span></div><div class="line"><span class="meta">	.cfi_startproc</span></div><div class="line">	subq	<span class="number">$8</span>, %rsp</div><div class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></div><div class="line">	movl	<span class="number">$4950</span>, %esi</div><div class="line">	movl	$.LC1, %edi</div><div class="line">	xorl	%eax, %eax</div><div class="line">	<span class="keyword">call</span>	printf</div><div class="line">	xorl	%eax, %eax</div><div class="line">	addq	<span class="number">$8</span>, %rsp</div><div class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">8</span></div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>看到了吧，这一次的 <code>test</code> 函数，我没有加 <code>inline</code>，在开启编译器优化的情况下，它还是可以自动去优化的。<br>你还会说，那啥，那啥……你还想说什么，自己去验证吧。我可以做最后一个实验。<br>现在把 <code>main.cpp</code> 改成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> prime[<span class="number">100</span>];</div><div class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= i; ++n)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">bool</span> is_prime = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(n)); ++j)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (n % j == <span class="number">0</span>)</div><div class="line">      &#123;</div><div class="line">        is_prime = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (is_prime)</div><div class="line">    &#123;</div><div class="line">      prime[k] = n;</div><div class="line">      ++k;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; k; ++n)</div><div class="line">  &#123;</div><div class="line">    sum += prime[n];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, test(<span class="number">100</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯…是有点儿长，我可是把 <code>test</code> 函数声明为 <code>inline</code> 的！然后在 <code>Debug</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00131ABE  <span class="keyword">push</span>        <span class="number">64h</span>  </div><div class="line">00131AC0  <span class="keyword">call</span>        <span class="keyword">test</span> (<span class="number">013102Dh</span>)  </div><div class="line">00131AC5  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">4</span>  </div><div class="line">00131AC8  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">00131AC9  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0137B30h</span>)  </div><div class="line">00131ACE  <span class="keyword">call</span>        _printf (<span class="number">0131339h</span>)  </div><div class="line">00131AD3  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>在 <code>Release</code> 下反汇编：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">  std:</span>:printf(<span class="string">"%d\n"</span>, <span class="keyword">test</span>(<span class="number">100</span>))<span class="comment">;</span></div><div class="line">00FC1170  <span class="keyword">call</span>        <span class="keyword">test</span> (<span class="number">0FC1040h</span>)  </div><div class="line">00FC1175  <span class="keyword">push</span>        <span class="built_in">eax</span>  </div><div class="line">00FC1176  <span class="keyword">push</span>        offset string <span class="string">"%d\n"</span> (<span class="number">0FC20F8h</span>)  </div><div class="line">00FC117B  <span class="keyword">call</span>        printf (<span class="number">0FC1010h</span>)  </div><div class="line">00FC1180  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>我声明了 <code>inline</code>，可是无论开不开优化，它也不帮我优化了。</p>
<h3 id="八、inline-的真正意义"><a href="#八、inline-的真正意义" class="headerlink" title="八、inline 的真正意义"></a>八、inline 的真正意义</h3><p>现在你该停下来思考思考了，什么是 <code>inline</code>？是“内联”吗？<code>inline</code> 的意义是什么？发起一个“内联”请求吗？<br>但事实上，你会发现，有时候，你不用 <code>inline</code>，会报错；有时候，你用了 <code>inline</code>，又会报错。你期望使用 <code>inline</code> 可以优化程序效率，但貌似跟你加不加 <code>inline</code> 没有什么关系啊？<br><code>inline</code> 的意义，似乎与“内联”，已经渐行渐远了。</p>
<p>好好的思考一下。<br><img src="http://i1.piimg.com/594413/4af9ac37c897da89.png" alt="Markdown"></p>
<p>我们还是继续翻开我们的 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">cppreference</a>，注意到这里有一段话：</p>
<blockquote>
<p>The original intent of the inline keyword was to serve as an indicator to the optimizer that inline substitution of a function is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (copying the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.<br>Since this meaning of the keyword <code>inline</code> is non-binding, compilers are free to use inline substitution for any function that’s not marked inline, and are free to generate function calls to any function marked inline. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above. </p>
</blockquote>
<p>看不懂没关系，其实它就是说：在很久很久以前，<code>inline</code> 作为给编译器优化的提示符，而 <code>inline</code> 的含义是非绑定的，编译器可以自由的选择、决定是否 inline 一个函数。而如今，编译器根本不需要这样的提示，如果它认为一个函数值得 inline，它会自动 inline，否则，即使你 inline 了，它也会拒绝。<br>可以看看这一篇 <a href="https://stackoverflow.com/questions/1759300/when-should-i-write-the-keyword-inline-for-a-function-method/1759575#1759575" target="_blank" rel="external">SO上的回答</a>：</p>
<blockquote>
<p>It is said that inline hints to the compiler that you think the function should be inlined. That may have been true in 1998, but a decade later the compiler needs no such hints. Not to mention humans are usually wrong when it comes to optimizing code, so most compilers flat out ignore the ‘hint’.</p>
<ul>
<li><code>static</code> - the variable/function name cannot be used in other compilation units. Linker needs to make sure it doesn’t accidentally use a statically defined variable/function from another compilation unit.</li>
<li><code>extern</code> - use this variable/function name in this compilation unit but don’t complain if it isn’t defined. The linker will sort it out and make sure all the code that tried to use some extern symbol has its address.</li>
<li><code>inline</code> - this function will be defined in multiple compilation units, don’t worry about it. The linker needs to make sure all compilation units use a single instance of the variable/function.</li>
</ul>
</blockquote>
<p>现在你应该差不多能够理解了，现在的编译器，并不需要你用 <code>inline</code> 去提醒，不要小看搞编译器那帮人，想着帮编译器优化的，一般人往往是错误的。所以，<strong>Ⅵ. 当且仅当你想用 <code>inline</code> 去优化程序时，不要使用 <code>inline</code></strong>。<br><code>inline</code> 这个关键字的翻译，就是一个坑，它真正的意义并不是去内联一个函数，而是表示 <strong><em>哥，别怕！无论你看到了多少个定义，但实体就我一个！</em></strong><br>在这个 <a href="http://en.cppreference.com/w/cpp/language/inline#Description" target="_blank" rel="external">cppreference</a> 里，最重要的就是这一句话：</p>
<blockquote>
<p>Because the meaning of the keyword inline for functions came to mean “multiple definitions are permitted” rather than “inlining is preferred”, that meaning was extended to variables. </p>
</blockquote>
<p>翻译过来就是：<strong>Ⅶ. <code>inline</code> 的含义更多的是“允许多重定义”而不是“优先选择内联”</strong>。</p>
<p>最后希望看完这篇文章的童鞋们，都可以深刻的理解C++的<code>inline</code>。</p>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><ul>
<li>Ⅰ.<code>inline</code> 要跟函数的定义放在一块</li>
<li>Ⅱ. <code>inline</code> 函数的定义放在头文件中，而不放在源文件中</li>
<li>Ⅲ. 当且仅当函数定义在头文件且有可能被多个源文件包含时，使用 <code>inline</code></li>
<li>Ⅳ. 不要把 <code>inline</code>用于类成员函数</li>
<li>Ⅴ. 模板不需要声明为 <code>inline</code>，也具有 <code>inline</code> 的语义</li>
<li>Ⅵ. 当且仅当你想用 <code>inline</code> 去优化程序时，不要使用 <code>inline</code></li>
<li>Ⅶ. <code>inline</code> 的含义更多的是“允许多重定义”而不是“优先选择内联”</li>
</ul>
<p>※注：以上总结适用于不熟悉、不了解 inline 的同学。若对以上内容都了解，使用 inline 的时候，很明白很清楚在做什么，会发生什么，那就随便怎么用啦！有的时候用了，就是为了好看一点呀！(～￣▽￣)～ </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6554591.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://alinshans.github.io/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://alinshans.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之那些年踩过的坑(一)</title>
    <link href="http://alinshans.github.io/2017/05/22/p1705221/"/>
    <id>http://alinshans.github.io/2017/05/22/p1705221/</id>
    <published>2017-05-22T01:53:51.000Z</published>
    <updated>2017-05-22T03:27:14.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注：本文来自于我的一篇博客 <a href="http://www.cnblogs.com/GodA/p/6501505.html" target="_blank" rel="external">http://www.cnblogs.com/GodA/p/6501505.html</a> ，修改而成。</em></p>
</blockquote>
<p>这一篇聊聊关于C++中的名称空间（namespace）。</p>
<h3 id="一、避免在全局范围内使用-using-namespace-xxx"><a href="#一、避免在全局范围内使用-using-namespace-xxx" class="headerlink" title="一、避免在全局范围内使用 using namespace xxx"></a>一、避免在全局范围内使用 using namespace xxx</h3><p>注意这个标题中的限定词，<strong>避免</strong>在<strong>全局范围内</strong>使用。之前很喜欢写代码开头就写上 <code>using namespace std</code>，因为可以省很多事，比写什么 <code>cout</code>，<code>endl</code> 方便多了。后来我在写 <a href="https://github.com/Alinshans/MyTinySTL" target="_blank" rel="external">MyTinySTL</a> 这个项目时，最后写测试，为了方便，就用了 <code>using namespace std</code>，写的时候是挺爽的，一运行就炸了。错误长的惨不忍睹，一大堆的名称冲突。当你使用了 <code>using namespace std</code> 的时候，就把 <code>std</code> 这个名称空间内的内容直接引用到了当前空间，如果跟当前空间的函数、类等重名了，那么编译就不通过了，这个就叫<code>名称污染</code>。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> your</div><div class="line">&#123;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="built_in">vector</span>() = <span class="keyword">default</span>;</div><div class="line">  ~<span class="built_in">vector</span>() = <span class="keyword">default</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  T* data;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> your;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你编译它，就会得到类似不明确的符号 vector 啊，may be <code>std::vector</code> or <code>your::vector</code> 啊之类的。当然了，这太明显了，谁都会看出来。问题就在于，我们不能把问题是否发生，寄托于我们是否能够看出来。当代码多了，文件多了，几十个几百个，上万行十万行，你确定你还记得你在哪个头文件 using 了什么东西？然后在一层一层 include 的情况下，莫名其妙的就炸掉了。所以，还是从根源上杜绝问题比较好。</p>
<p>刚刚说的是 namespace std，但对于其它的 namespace 而言，也是一样的。如果是你自己写的，你都尚未能保证你能避开所有重复的命名，除非你自己写个玩具中的 demo，如果是别人写的，那就更加不可控了。</p>
<p>其实解决办法有很多的，或者说是预防措施，又或者说，其实是一个良好的编程习惯。比起直接在全局使用 <code>using namespace xxx</code> 好一点的做法是：<strong>在局部声明并且只声明需要的那个部分</strong>。比如如果在某个作用域内经常要使用 <code>std::cout</code>，<code>std::endl</code> 等，你可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1+1="</span> &lt;&lt; <span class="number">1</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1+2="</span> &lt;&lt; <span class="number">1</span> + <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1+3="</span> &lt;&lt; <span class="number">1</span> + <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然最好的还是在你要使用的东西前显示指定出它归属的名称空间，一来可以更清晰的知道它是来自哪里的库，二来这样写几乎放多久都不会有错。习惯成自然，养成了这个习惯，你就根本不会去想到有 <code>using namespace xxx</code> 这种东西了。</p>
<h3 id="二、Best-Practices"><a href="#二、Best-Practices" class="headerlink" title="二、Best Practices"></a>二、Best Practices</h3><p>在 <a href="https://www.amazon.com/dp/0321113586/?tag=stackoverfl08-20" target="_blank" rel="external">C++ Coding Standards</a> 里，有这样一段话：</p>
<blockquote>
<p><strong>Summary</strong><br>Namespace usings are for your convenience, not for you to inflict on others: Never write a using declaration or a using directive before an #include directive.<br>Corollary: In header files, don’t write namespace-level using directives or using declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header #includes might appear after them.)<br><strong>Discussion</strong><br>In short: You can and should use namespace using declarations and directives liberally in your implementation files after #include directives and feel good about it. Despite repeated assertions to the contrary, namespace using declarations and directives are not evil and they do not defeat the purpose of namespaces. Rather, they are what make namespaces usable.</p>
</blockquote>
<p>在 <a href="http://www.umich.edu/~eecs381/handouts/C++_Coding_Standards.pdf" target="_blank" rel="external">C++ Coding Standards for EECS 381</a>中 P32 有一段话：</p>
<blockquote>
<ul>
<li>Follow guidelines for namespace <code>using</code> statements.<ul>
<li>Namespace declarations and directives.<ul>
<li>No namespace using declarations or directives are allowed at the top level of a header file.<ul>
<li>OK if scoped within an inline or member function body or a class declaration.</li>
</ul>
</li>
<li>In <code>.cpp</code> files,<ul>
<li>Place using statements only after all <code>#includes</code>.</li>
<li>Prefer using declarations of specific Standard Library functions or classes to using namespace<br>directives.</li>
<li>Especially in this course, prefer using declarations or directives to explicitly qualifying Standard<br>Library names with <code>std::</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Namespaces" target="_blank" rel="external">Google C++ Style Guide</a> 中有一条：</p>
<blockquote>
<p>You may not use a using-directive to make all names from a namespace available.</p>
</blockquote>
<p>看了这几段，就胜过我千言万语了。</p>
<h3 id="三、关于匿名-namespace"><a href="#三、关于匿名-namespace" class="headerlink" title="三、关于匿名 namespace"></a>三、关于匿名 namespace</h3><p>关于 unnamed namespace，<a href="http://en.cppreference.com/w/cpp/language/namespace" target="_blank" rel="external">cppreference</a> 如是说到：</p>
<blockquote>
<p>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have internal linkage, which means that any name that is declared within an unnamed namespace has internal linkage. </p>
</blockquote>
<p>也就是说，现在，在匿名空间里的成员，具有内部链接，跟 static 没啥区别了。不过依然要注意，在同一层次中，可以有多个匿名空间，不过这些匿名空间会被整合成一个，所以不能像这样写，会报重定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然在不同空间内的匿名空间，当然就是不同的啦，下面这样就可以通过了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">namespace</span> n1</div><div class="line">&#123;</div><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="string">"\n"</span>; &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  foo();</div><div class="line">  n1::foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables" target="_blank" rel="external">Google C++ Style Guide</a> 中是这样说 unnamed namesapce 的：</p>
<blockquote>
<p>When definitions in a <code>.cc</code> file do not need to be referenced outside that file, place them in an unnamed namespace or declare them <code>static</code>. Do not use either of these constructs in <code>.h</code> files.<br><strong>Definition</strong><br>All declarations can be given internal linkage by placing them in unnamed namespaces, and functions and variables can be given internal linkage by declaring them <code>static</code>. This means that anything you’re declaring can’t be accessed from another file. If a different file declares something with the same name, then the two entities are completely independent.<br><strong>Decision</strong><br>Use of internal linkage in <code>.cc</code> files is encouraged for all code that does not need to be referenced elsewhere. Do not use internal linkage in <code>.h</code> files.</p>
</blockquote>
<p>他们鼓励在实现文件中，把那些不需要外部引用的东西放进匿名空间中。陈硕大大在他的 <a href="https://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf" target="_blank" rel="external">CppPractice</a> 中，第一个提到的就是慎用匿名空间。我觉得，对于他说的不利之处，现在来看，主要还是是第一点。因为匿名namespace里的东西是匿名的，所以万一以后有一天想引用它了，也说不准。其实还是用个具体名称，也不麻烦。对于那些实现细节，或者不希望暴露的，我还是喜欢扔进一个 <code>namespace details{}</code> 或者什么 <code>namespace impl {}</code> 里。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>总结就两点：</p>
<ul>
<li><strong>不要使用 <code>using namespace xxx</code>，使用 <code>xxx::yyy</code></strong></li>
<li><strong>使用具名 namespace</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：本文来自于我的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/GodA/p/6501505.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com
    
    </summary>
    
      <category term="C++之那些年踩过的坑" scheme="http://alinshans.github.io/categories/C-%E4%B9%8B%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="C++" scheme="http://alinshans.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello, my world</title>
    <link href="http://alinshans.github.io/2017/05/17/p1705171/"/>
    <id>http://alinshans.github.io/2017/05/17/p1705171/</id>
    <published>2017-05-17T05:20:35.000Z</published>
    <updated>2017-05-17T05:56:50.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本在博客园和Github上有写一些随笔和笔记，不过博客园的编辑真的好难看，还不如 Markdown 格式的好看，所以就搭了一个新的博客，会陆续把一些以前写的搬到这里，以及新随笔和笔记都会在这里首发。</p>
<h2 id="Hello-my-world"><a href="#Hello-my-world" class="headerlink" title="Hello, my world"></a>Hello, my world</h2><p>大概每个人接触编程后，写的第一个程序都是 Hello world 。我们能轻松的用几行代码，就在一个黑框框或者更漂亮的界面上输出一个 Hello world，多亏了我们是站在了许多巨人的肩膀上。多希望有一天，我可以在自己创造的世界里，说一声 Hello, my world!</p>
<h2 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h2><p>以上所说的”自己创造的世界”，其实说的是自己创造自己喜欢的环境，可以是一个系统，可以是一种语言，可以是一个框架，甚至可以是一种语法。只要能让自己用得开心，想怎么改就怎么改，想怎么运行就怎么运行。当然，不可能从零开始，也不可能去重写所有的东西。这一个过程应该是自顶向下的，从能最直接接触到的东西开始，有不顺手的地方，那就给它包装，或者重写，直到自己顺手了，开心了为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本在博客园和Github上有写一些随笔和笔记，不过博客园的编辑真的好难看，还不如 Markdown 格式的好看，所以就搭了一个新的博客，会
    
    </summary>
    
      <category term="其他" scheme="http://alinshans.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
